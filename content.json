{"meta":{"title":"Yang Yang的博客","subtitle":null,"description":null,"author":"Yang Yang","url":"http://mryy.com"},"pages":[{"title":"Android内存泄漏分析实战","date":"2017-04-19T12:52:34.000Z","updated":"2017-04-19T12:52:41.000Z","comments":true,"path":"android/Android内存泄漏分析实战.html","permalink":"http://mryy.com/android/Android内存泄漏分析实战.html","excerpt":"","text":"公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。 #内存泄漏基本概念 内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：1、静态变量持有Activity的context。2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。 #内存检测工具 ##LeakCananry ###使用步骤 LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图： ###整体流程LeakCananry实现步骤大致是：实现大致步骤是：1、自动把activity加入到KeyedWeakReference2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。 ###结论方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。 ##观看整体内存使用情况详情参见官方文档：https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations使用adb shell，进入手机adb，执行命令： 1dumpsys meminfo &lt;包名&gt; [-参数] 可以查看应用不同部分内存分配情况。比如Java heap，Native heap等输出是目前具体应用的内存分配，单位是kilobytes因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。 结果如下： 分析各个参数：Private Clean/Dirty RAM：这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。 PSS Total:我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。 Dalvik Heap：该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。 .so mmap / .dex mmap这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。 上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。 ##DDMS ####使用流程 启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的； 将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”； 链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息； 点击选中想要监测的进程，比如system_process进程； 点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标； 点击Heap视图中的“Cause GC”按钮； 此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。 ####如何检测内存泄漏？Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大 通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。 ##MAT然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。在了解MAT具体使用之前，要先了解一些相关概念。 ####支配树支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。 ####SHALLOWHEAP和RETAINED HEAPShallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：Shallow Size对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。Retained SizeRetained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图： A对象的Retained Size=A对象的Shallow SizeB对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 以上概念，都是在使用MAT进行内存分析经常使用的。我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。 在使用MAT分析内存泄漏的过程中，主要流程就是：1、分析retained heap，找一个使很多对象无法被释放的内存。2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。 ####MAT的下载与使用下载地址：https://eclipse.org/mat/downloads.php这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。首先，在DDMS中选择要检测的进程并dump HPROF file，如下图： HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。 转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。 使用方法：/.hprof-conv.exe a.hprof b.hprofa 是输入hprof文件名，b是输出文件名。然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。如下： ####利用MAT分析内存泄漏分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。 在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。 上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。 Retained heap表示因为这个对象，会导致多少对象无法回收。 右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。outcoming reference就是子节点，查看一些当前对象引用着的对象。 此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。 ##实战分析下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。 ###1、使用DDMS查看内存使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：使用前： 使用后： 通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。 但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。 下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析： ###2、使用MAT分析内存转储前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比： 点击右上角的红色叹号： 对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。再看一下使用前后直方图中的retained heap： 可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。右击直方图中的NewActivity，可以看见如下选项： 用的比较多的是List objects和Merger shortest Paths to GC Roots。List objects：Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。 Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。 在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用： 排除系统的对象，还是主要分析我们编写的程序。 最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。 去掉LeakCanary，再次测试发现data object的值确实下降了不少。 继续分析，发现newActivity引用了一个 致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。接下来，在直方图中过滤出服务端的类：可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。 ##结论在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。","raw":null,"content":null},{"title":"EventBus 源码分析","date":"2017-04-19T11:15:03.000Z","updated":"2017-04-19T12:41:57.000Z","comments":true,"path":"android/EventBus-源码分析.html","permalink":"http://mryy.com/android/EventBus-源码分析.html","excerpt":"","text":"EventBusEventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。 register 发布过程register 主要包括两个过程： 找到当前注册的对象中onEvent相关订阅方法 订阅者对找出的方法进行订阅。 findSubscriberMethods利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。 123456789101112131415if (modifierString.length() == 0) &#123; threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123; threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123; threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123; threadMode = ThreadMode.Async; &#125; else &#123; if (skipMethodVerificationForClasses.containsKey(clazz)) &#123; continue; &#125; else &#123; throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method); &#125; &#125; 上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。 subscribe 订阅过程第一阶段找到所有方法后，第二阶段先执行下面的代码： 123for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod, sticky, priority);&#125; subscribe方法主要包含以下过程： 根据EventType找到订阅该事件的订阅队列 找到subsciber订阅的全部事件，并将当前事件添加进去。 处理stick类型的event。 subscriptionsByEventTypeEventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。 123456CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; 上面的代码就获得了某个event对应的订阅队列。然后根据优先级将subscription插入合适的位置。 123456for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125;&#125; typesBySubscriber同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据： 123456List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents);&#125;subscribedEvents.add(eventType); sticky第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。 123456synchronized (stickyEvents) &#123; stickyEvent = stickyEvents.get(eventType);&#125;if (stickyEvent != null) &#123; postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());&#125; post过程currentPostingThreadState虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量： 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; postSingleEvent流程： 将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。 寻找该事件的订阅者，并将事件交给订阅的subscription进行处理： 123synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(clazz); &#125; subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。 12345678910111213141516for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125;&#125; 寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。 第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件： 123456if (!subscriptionFound) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125;&#125; ​ ​ postToSubscriptionEventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单： 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case PostThread: invokeSubscriber(subscription, event); break; case MainThread: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BackgroundThread: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case Async: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况： 直接invokeSubscriber 将subscription和event给到指定的Poster中 invokeSubscriber方法中首先直接反射调用注册该事件的方法： 1subscription.subscriberMethod.method.invoke(subscription.subscriber, event); 从发布到订阅，就这么简单粗暴的完成了。 PosterEventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。 HandlerPoster 如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下： 12345678910PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125;&#125; ​ PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境： 12345678910111213141516171819202122while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125;&#125; handleMessage中流程： 从pendingPostQueue中取出待处理的post，调用相应subscription执行 防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。 总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。 BackgroundPosterHandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。 runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行： 1234567891011121314while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost);&#125; 至此，EventBus的发布订阅模型分析完成。","raw":null,"content":null},{"title":"RecyclerView 源码学习及自定义LayoutManager","date":"2017-04-19T12:49:31.000Z","updated":"2017-04-19T12:49:43.000Z","comments":true,"path":"android/RecyclerView-源码学习及自定义LayoutManager.html","permalink":"http://mryy.com/android/RecyclerView-源码学习及自定义LayoutManager.html","excerpt":"","text":"RecyclerView 的三驾马车LayoutManager掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。 measure视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。 layoutlayout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。 在RecyclerView 进行 onMeasure的时候，调用了如下代码： 12345if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec);&#125; else &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);&#125; 如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为 AdapterLayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。 ViewHolderadapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。 ViewHolder构造代码如下： 123456public ViewHolder(View itemView) &#123; if (itemView == null) &#123; throw new IllegalArgumentException(&quot;itemView may not be null&quot;); &#125; this.itemView = itemView;&#125; 其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下： 1234567 public final VH createViewHolder(ViewGroup parent, int viewType) &#123; TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG); final VH holder = onCreateViewHolder(parent, viewType); holder.mItemViewType = viewType; TraceCompat.endSection(); return holder;&#125; 而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。 ViewHolder中的ItemViewItemDecorationItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。 在说明ItemDecoration之前首先要看一下view中draw事件的传递： View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程： 绘制背景 drawBackground 绘制视图内容，即调用自身的 onDraw 绘制child view 使用ItemDecoration，主要通过覆写以下方法： getItemOffsets可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码： onDrawRecyclerView 被父布局调用draw方法，draw方法中关键代码： 12345678public void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ...&#125; 其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有： 1234567public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法： 12345678View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125; #### measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘， 上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。 基本概念RecyclerLayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。 Scrap 或 RecyclerRecycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。 每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。 使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind 小结其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView 自定义LayoutManagergenerateDefaultLayoutParams作用：控制每个item的layoutParams为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp 初始布局 onLayoutChildren这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。 12345if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return;&#125; 这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘： 1234567891011if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2; startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2; interval = 10; detachAndScrapView(scrap, recycler);&#125; 这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘： 12recycler.getViewForPosition(0); addView(scrap); 测绘完成后，再重新放回recycler中，调用 1detachAndScrapView(scrap, recycler); 最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用 1detachAndScrapAttachedViews(recycler); 然后就可以进行layoutChildren的过程了。 先来一个简单的，如下： 123456789int left = 100, top = 0; for (int i = 0; i&lt; getItemCount(); i++) &#123; if (outOfRange(top)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight); top += mDecoratedChildHeight + interval; &#125; 基本效果就是这样： 处理滑动 canScroll 和 scrollXXXBy基本的布局有了之后，就可以处理滑动了。RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法： 关键代码如下： 123456789101112131415161718 final boolean canScrollHorizontally = mLayout.canScrollHorizontally(); final boolean canScrollVertically = mLayout.canScrollVertically(); ... case MotionEvent.ACTION_MOVE: ... if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123; mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1); startScroll = true; &#125;if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123; mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1); startScroll = true; &#125; ...if (startScroll) &#123; setScrollState(SCROLL_STATE_DRAGGING); &#125; ...return mScrollState == SCROLL_STATE_DRAGGING; 这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。比如我们要允许竖直方向的滑动，直接重写如下： 1234@Overridepublic boolean canScrollVertically() &#123; return true;&#125; 再来看一下事件拦截以后，在onTouchEvent中怎么处理的： 123456if (scrollByInternal( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, vtev)) &#123;getParent().requestDisallowInterceptTouchEvent(true); &#125; 代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法： 12345678if (x != 0) &#123; consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState); unconsumedX = x - consumedX;&#125;if (y != 0) &#123; consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState); unconsumedY = y - consumedY;&#125; 就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。 除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子： 1234@Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; return 0; &#125; 返回0的时候，无论怎样都会小于传入的dy，看一下效果： 可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。 分析到这里，基本可以确定如何添加滚动效果了，关键在两点： canScrollXXX中返回true 在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。 为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。 首先，用一个全局变量 List offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化： 1234for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval;&#125; 滑动方面的方法： 1234567@Overridepublic int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; layoutItems(recycler, state, dy); return willScroll;&#125; 并且，原先对item的layout的过程也要进行一些修改： 12345678910111213141516171819202122private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125;&#125; 上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。到此为止，就有了滑动的动画效果： 缩放效果经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。 实现的思路也比较简单，定一条基准线middle如下： 在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。 新的layoutItems代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125;&#125; 最后可以得到下面这样一个比较粗糙的效果： 最后，来贴一下完整的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package rouchuan.circlelayoutmanager;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * Created by yangyang on 2017/3/13. */public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123; private int mDecoratedChildWidth; private int mDecoratedChildHeight; private int interval; private int middle; private int offset; private List&lt;Integer&gt; offsetList; public SimpleLayoutManager(Context context) &#123; offsetList = new ArrayList&lt;&gt;(); &#125; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return; &#125; //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的 if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); interval = 10; middle = (getVerticalSpace() - mDecoratedChildHeight) / 2; detachAndScrapView(scrap, recycler); &#125; //回收全部attach 的 view 到 recycler 并重新排列 int property = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval; &#125; detachAndScrapAttachedViews(recycler); layoutItems(recycler, state, 0); &#125; @Override public boolean canScrollVertically() &#123; return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0; layoutItems(recycler, state, dy); return willScroll; &#125; private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125; &#125; private boolean outOfRange(float targetOffSet) &#123; return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight || targetOffSet &lt; -mDecoratedChildHeight; &#125; private int getHorizontalSpace() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125; private int getVerticalSpace() &#123; return getHeight() - getPaddingTop() - getPaddingBottom(); &#125;&#125;","raw":null,"content":null},{"title":"android","date":"2017-04-19T12:58:07.000Z","updated":"2017-04-19T12:58:07.000Z","comments":true,"path":"android/index.html","permalink":"http://mryy.com/android/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"categories","date":"2017-04-19T13:19:02.000Z","updated":"2017-04-19T13:19:02.000Z","comments":true,"path":"categories/index.html","permalink":"http://mryy.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-04-19T13:18:52.000Z","updated":"2017-04-19T13:18:52.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://mryy.com/tags/index-1.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-04-19T13:18:38.000Z","updated":"2017-04-19T13:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://mryy.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"EventBus 源码分析","slug":"EventBus-源码分析","date":"2017-04-19T11:15:03.000Z","updated":"2017-04-19T12:41:57.000Z","comments":true,"path":"2017/04/19/EventBus-源码分析/","link":"","permalink":"http://mryy.com/2017/04/19/EventBus-源码分析/","excerpt":"","text":"EventBusEventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。 register 发布过程register 主要包括两个过程： 找到当前注册的对象中onEvent相关订阅方法 订阅者对找出的方法进行订阅。 findSubscriberMethods利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。 123456789101112131415if (modifierString.length() == 0) &#123; threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123; threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123; threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123; threadMode = ThreadMode.Async; &#125; else &#123; if (skipMethodVerificationForClasses.containsKey(clazz)) &#123; continue; &#125; else &#123; throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method); &#125; &#125; 上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。 subscribe 订阅过程第一阶段找到所有方法后，第二阶段先执行下面的代码： 123for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod, sticky, priority);&#125; subscribe方法主要包含以下过程： 根据EventType找到订阅该事件的订阅队列 找到subsciber订阅的全部事件，并将当前事件添加进去。 处理stick类型的event。 subscriptionsByEventTypeEventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。 123456CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; 上面的代码就获得了某个event对应的订阅队列。然后根据优先级将subscription插入合适的位置。 123456for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125;&#125; typesBySubscriber同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据： 123456List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents);&#125;subscribedEvents.add(eventType); sticky第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。 123456synchronized (stickyEvents) &#123; stickyEvent = stickyEvents.get(eventType);&#125;if (stickyEvent != null) &#123; postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());&#125; post过程currentPostingThreadState虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量： 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; postSingleEvent流程： 将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。 寻找该事件的订阅者，并将事件交给订阅的subscription进行处理： 123synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(clazz); &#125; subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。 12345678910111213141516for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125;&#125; 寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。 第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件： 123456if (!subscriptionFound) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125;&#125; ​ ​ postToSubscriptionEventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单： 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case PostThread: invokeSubscriber(subscription, event); break; case MainThread: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BackgroundThread: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case Async: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况： 直接invokeSubscriber 将subscription和event给到指定的Poster中 invokeSubscriber方法中首先直接反射调用注册该事件的方法： 1subscription.subscriberMethod.method.invoke(subscription.subscriber, event); 从发布到订阅，就这么简单粗暴的完成了。 PosterEventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。 HandlerPoster 如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下： 12345678910PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125;&#125; ​ PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境： 12345678910111213141516171819202122while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125;&#125; handleMessage中流程： 从pendingPostQueue中取出待处理的post，调用相应subscription执行 防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。 总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。 BackgroundPosterHandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。 runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行： 1234567891011121314while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost);&#125; 至此，EventBus的发布订阅模型分析完成。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"RecyclerView 源码学习及自定义LayoutManager","slug":"RecyclerView-源码学习及自定义LayoutManager","date":"2017-03-13T15:49:31.000Z","updated":"2017-04-19T13:59:28.000Z","comments":true,"path":"2017/03/13/RecyclerView-源码学习及自定义LayoutManager/","link":"","permalink":"http://mryy.com/2017/03/13/RecyclerView-源码学习及自定义LayoutManager/","excerpt":"","text":"RecyclerView 的三驾马车LayoutManager掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。 measure视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。 layoutlayout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。 在RecyclerView 进行 onMeasure的时候，调用了如下代码： 12345if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec);&#125; else &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);&#125; 如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为 AdapterLayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。 ViewHolderadapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。 ViewHolder构造代码如下： 123456public ViewHolder(View itemView) &#123; if (itemView == null) &#123; throw new IllegalArgumentException(&quot;itemView may not be null&quot;); &#125; this.itemView = itemView;&#125; 其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下： 1234567 public final VH createViewHolder(ViewGroup parent, int viewType) &#123; TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG); final VH holder = onCreateViewHolder(parent, viewType); holder.mItemViewType = viewType; TraceCompat.endSection(); return holder;&#125; 而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。 ViewHolder中的ItemViewItemDecorationItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。 在说明ItemDecoration之前首先要看一下view中draw事件的传递： View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程： 绘制背景 drawBackground 绘制视图内容，即调用自身的 onDraw 绘制child view 使用ItemDecoration，主要通过覆写以下方法： getItemOffsets可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码： onDrawRecyclerView 被父布局调用draw方法，draw方法中关键代码： 12345678public void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ...&#125; 其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有： 1234567public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法： 12345678View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125; #### measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘， 上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。 基本概念RecyclerLayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。 Scrap 或 RecyclerRecycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。 每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。 使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind 小结其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView 自定义LayoutManagergenerateDefaultLayoutParams作用：控制每个item的layoutParams为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp 初始布局 onLayoutChildren这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。 12345if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return;&#125; 这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘： 1234567891011if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2; startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2; interval = 10; detachAndScrapView(scrap, recycler);&#125; 这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘： 12recycler.getViewForPosition(0); addView(scrap); 测绘完成后，再重新放回recycler中，调用 1detachAndScrapView(scrap, recycler); 最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用 1detachAndScrapAttachedViews(recycler); 然后就可以进行layoutChildren的过程了。 先来一个简单的，如下： 123456789int left = 100, top = 0; for (int i = 0; i&lt; getItemCount(); i++) &#123; if (outOfRange(top)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight); top += mDecoratedChildHeight + interval; &#125; 基本效果就是这样： 处理滑动 canScroll 和 scrollXXXBy基本的布局有了之后，就可以处理滑动了。RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法： 关键代码如下： 123456789101112131415161718 final boolean canScrollHorizontally = mLayout.canScrollHorizontally(); final boolean canScrollVertically = mLayout.canScrollVertically(); ... case MotionEvent.ACTION_MOVE: ... if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123; mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1); startScroll = true; &#125;if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123; mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1); startScroll = true; &#125; ...if (startScroll) &#123; setScrollState(SCROLL_STATE_DRAGGING); &#125; ...return mScrollState == SCROLL_STATE_DRAGGING; 这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。比如我们要允许竖直方向的滑动，直接重写如下： 1234@Overridepublic boolean canScrollVertically() &#123; return true;&#125; 再来看一下事件拦截以后，在onTouchEvent中怎么处理的： 123456if (scrollByInternal( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, vtev)) &#123;getParent().requestDisallowInterceptTouchEvent(true); &#125; 代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法： 12345678if (x != 0) &#123; consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState); unconsumedX = x - consumedX;&#125;if (y != 0) &#123; consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState); unconsumedY = y - consumedY;&#125; 就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。 除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子： 1234@Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; return 0; &#125; 返回0的时候，无论怎样都会小于传入的dy，看一下效果： 可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。 分析到这里，基本可以确定如何添加滚动效果了，关键在两点： canScrollXXX中返回true 在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。 为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。 首先，用一个全局变量 List offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化： 1234for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval;&#125; 滑动方面的方法： 1234567@Overridepublic int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; layoutItems(recycler, state, dy); return willScroll;&#125; 并且，原先对item的layout的过程也要进行一些修改： 12345678910111213141516171819202122private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125;&#125; 上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。到此为止，就有了滑动的动画效果： 缩放效果经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。 实现的思路也比较简单，定一条基准线middle如下： 在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。 新的layoutItems代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125;&#125; 最后可以得到下面这样一个比较粗糙的效果： 最后，来贴一下完整的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package rouchuan.circlelayoutmanager;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * Created by yangyang on 2017/3/13. */public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123; private int mDecoratedChildWidth; private int mDecoratedChildHeight; private int interval; private int middle; private int offset; private List&lt;Integer&gt; offsetList; public SimpleLayoutManager(Context context) &#123; offsetList = new ArrayList&lt;&gt;(); &#125; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return; &#125; //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的 if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); interval = 10; middle = (getVerticalSpace() - mDecoratedChildHeight) / 2; detachAndScrapView(scrap, recycler); &#125; //回收全部attach 的 view 到 recycler 并重新排列 int property = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval; &#125; detachAndScrapAttachedViews(recycler); layoutItems(recycler, state, 0); &#125; @Override public boolean canScrollVertically() &#123; return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0; layoutItems(recycler, state, dy); return willScroll; &#125; private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125; &#125; private boolean outOfRange(float targetOffSet) &#123; return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight || targetOffSet &lt; -mDecoratedChildHeight; &#125; private int getHorizontalSpace() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125; private int getVerticalSpace() &#123; return getHeight() - getPaddingTop() - getPaddingBottom(); &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Android内存泄漏分析实战","slug":"Android内存泄漏分析实战","date":"2016-12-21T12:52:34.000Z","updated":"2017-04-19T14:00:33.000Z","comments":true,"path":"2016/12/21/Android内存泄漏分析实战/","link":"","permalink":"http://mryy.com/2016/12/21/Android内存泄漏分析实战/","excerpt":"","text":"公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。 #内存泄漏基本概念 内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：1、静态变量持有Activity的context。2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。 #内存检测工具 ##LeakCananry ###使用步骤 LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图： ###整体流程LeakCananry实现步骤大致是：实现大致步骤是：1、自动把activity加入到KeyedWeakReference2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。 ###结论方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。 ##观看整体内存使用情况详情参见官方文档：https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations使用adb shell，进入手机adb，执行命令： 1dumpsys meminfo &lt;包名&gt; [-参数] 可以查看应用不同部分内存分配情况。比如Java heap，Native heap等输出是目前具体应用的内存分配，单位是kilobytes因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。 结果如下： 分析各个参数：Private Clean/Dirty RAM：这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。 PSS Total:我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。 Dalvik Heap：该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。 .so mmap / .dex mmap这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。 上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。 ##DDMS ####使用流程 启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的； 将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”； 链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息； 点击选中想要监测的进程，比如system_process进程； 点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标； 点击Heap视图中的“Cause GC”按钮； 此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。 ####如何检测内存泄漏？Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大 通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。 ##MAT然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。在了解MAT具体使用之前，要先了解一些相关概念。 ####支配树支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。 ####SHALLOWHEAP和RETAINED HEAPShallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：Shallow Size对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。Retained SizeRetained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图： A对象的Retained Size=A对象的Shallow SizeB对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 以上概念，都是在使用MAT进行内存分析经常使用的。我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。 在使用MAT分析内存泄漏的过程中，主要流程就是：1、分析retained heap，找一个使很多对象无法被释放的内存。2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。 ####MAT的下载与使用下载地址：https://eclipse.org/mat/downloads.php这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。首先，在DDMS中选择要检测的进程并dump HPROF file，如下图： HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。 转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。 使用方法：/.hprof-conv.exe a.hprof b.hprofa 是输入hprof文件名，b是输出文件名。然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。如下： ####利用MAT分析内存泄漏分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。 在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。 上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。 Retained heap表示因为这个对象，会导致多少对象无法回收。 右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。outcoming reference就是子节点，查看一些当前对象引用着的对象。 此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。 ##实战分析下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。 ###1、使用DDMS查看内存使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：使用前： 使用后： 通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。 但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。 下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析： ###2、使用MAT分析内存转储前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比： 点击右上角的红色叹号： 对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。再看一下使用前后直方图中的retained heap： 可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。右击直方图中的NewActivity，可以看见如下选项： 用的比较多的是List objects和Merger shortest Paths to GC Roots。List objects：Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。 Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。 在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用： 排除系统的对象，还是主要分析我们编写的程序。 最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。 去掉LeakCanary，再次测试发现data object的值确实下降了不少。 继续分析，发现newActivity引用了一个 致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。接下来，在直方图中过滤出服务端的类：可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。 ##结论在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"动态规划简介","slug":"动态规划简介","date":"2016-10-29T13:56:31.000Z","updated":"2017-04-19T14:00:12.000Z","comments":true,"path":"2016/10/29/动态规划简介/","link":"","permalink":"http://mryy.com/2016/10/29/动态规划简介/","excerpt":"","text":"动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。 #解题思路在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新的元素和已有结果是否存在某种关系。对于没有思路的题目，求解可以分为暴力递归（回溯），记忆性搜索，递归优化，时间或空间最终优化四个阶段。在碰到一道可以使用动态规划的题目的时候，如果还不知道怎么下手，那么第一步，一定要去想如何递归求解。所谓递归求解，说的简单点，就是一种穷举，文艺一点，也可以叫回溯。是的，在学习动态规划之前，一定要对回溯法有所了解。 123456789101112131415161718backtracking(member)&#123; //如果已经不可能再得到结果，直接返回。也叫剪枝，分支限界。 if(is_invalid) return; //如果得到最终结果，处理显示。 if(is_solution) print_result(); //递归即将进入下一层级，如果有数据在下一层级中需要使用，更新它们。 move_ahead(); //准备要进入递归的元素。 candidate[] candidates = get_candidates; for(candidate in candidates)&#123; backtracking(candidate) &#125; //递归回到当前层级，将数据更新回当前层级所需数据。 move_back();&#125; 上面就是回溯法的基本模板，看清来可能有点模糊，下面的第一道题目的第一个步骤，就将对此作出详细解释。 ##题目1 123给一个非负数组，你一开始处在数组收尾（index=0），数组中元素代表你能从当前位置向后跳的**最大**步数，问能否达到数组末尾。比如：A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. ###递归求解 最为直观的回溯法求解如下：思路十分直观，当我们到了每个位置，在此位置上，可以向后跳1到最大步数，在每一跳之后进行递归，依次类推穷举出所有情况，一旦有一种可以到达最终位置，那么我们就可以得到最终结果。1234567891011121314151617181920public class Solution &#123; public boolean canJumpFromPosition(int position, int[] nums) &#123; if (position == nums.length - 1) &#123; return true; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; return true; &#125; &#125; return false; &#125; public boolean canJump(int[] nums) &#123; return canJumpFromPosition(0, nums); &#125;&#125; 首先先进行一下简单的优化，在每一步判断下一跳位置的时候，为了尽快的到达最后的位置，我们很明显应该尽可能多走步数，一旦发现最后无法到达再减少步数。 1234// 原始代码for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++)// 新的代码for (int nextPosition = furthestJump; nextPosition &gt; position; nextPosition--) ###记忆化搜索（自顶向下动态规划）可以看到，上面的递归基本就是暴力解法，那么进一步的优化，就是在递归上面应用存储，已经计算过的分支不再继续进行计算。 123456789101112131415161718192021222324252627282930public class Solution &#123; Index[] memo; public boolean canJumpFromPosition(int position, int[] nums) &#123; //存储已经计算过的分支 if (memo[position] != Index.UNKNOWN) &#123; return memo[position] == Index.GOOD ? true : false; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; memo[position] = Index.GOOD; return true; &#125; &#125; memo[position] = Index.BAD; return false; &#125; public boolean canJump(int[] nums) &#123; memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; return canJumpFromPosition(0, nums); &#125;&#125; ###去递归（自底向上动态规划）去递归的过程，其实就是人为的分析并指定计算过程的过程。首先分析递归过程中的可变参数，这个可变参数就是循环中遍历的变量。这里很明显是当前位置 position。然后需要分析递归的运行顺序，这里可以人为画递归树。我们可以发现，运算实质是从右向左进行的。一个点能否达到某一个点，取决于它右边点的运算结果。 1234567891011121314151617181920212223242526enum Index &#123; GOOD, BAD, UNKNOWN&#125;public class Solution &#123; public boolean canJump(int[] nums) &#123; Index[] memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; int furthestJump = Math.min(i + nums[i], nums.length - 1); //去当前点的右边看是否有可达点。 for (int j = i + 1; j &lt;= furthestJump; j++) &#123; if (memo[j] == Index.GOOD) &#123; memo[i] = Index.GOOD; break; &#125; &#125; &#125; return memo[0] == Index.GOOD; &#125;&#125; ###贪心优化（贪心策略）上面的时间复杂度为O（mn），m是数组中最大值，n是数组个数。在分析上面循环的过程中，我们发现找到的第一个点可以到达一个可达点，那么当前位置就不需要再判断后面的步数。也就是说，一个点只要找到离他最近的可达点，那么它就变成了下一轮的可达点。下一轮一旦有一个点可以达到它，那么该点又成为下一轮新的可达点。这也就告诉我们，对于每个点，只要找到它右边第一个可达点即可。这也就是典型的贪心策略。我们可以从右向左，在某个可达点左边找一个最近的点可以达到它，更新该最近点为新的可达点，以此类推，知道最后的一个可达点是起始点。 1234567891011public class Solution &#123; public boolean canJump(int[] nums) &#123; int lastPos = nums.length - 1; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (i + nums[i] &gt;= lastPos) &#123; lastPos = i; &#125; &#125; return lastPos == 0; &#125;&#125; ##题目2给一个非负数组，从数组中选取任意个数字求和，要求所选元素均不相邻，求最大和。 ###直接寻找递归关系对于比较简单的dp，也可以寻找递推关系求解：这到题的递推关系在于，对于每一个新的元素，都可以选择取或者不取，用一个数组dp记录前面不同长度数组的最大和，那么对当前元素dp[i]，如果不取则最大和为dp[i-1],如果取则最大值为dp[i-2]+num[i];可以很轻易的根据递推关系写出动态规划： 1234567891011public class Solution &#123; public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length+1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2;i&lt;nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],nums[i]+dp[i-2]); &#125; return dp[nums.length];&#125; 同经典的钢条切割背包问题一样， 对于一个新出现的元素，选与不选是构成递归的重要策略。比如leetcode两道题目 ：https://leetcode.com/problems/house-robber/，https://leetcode.com/problems/house-robber-ii/，都是对于一个新出现的元素，进行选与不选两种决策去寻找递推关系，动态规划可能的O(N)解法基本也只会出现在这种决策中。 ###空间优化到这里还不算完，我们看见，对于每个dp[i]的计算，仅和dp[i-1]，dp[i-2]有关，这也告诉我们根本不需要一个数组，因为以前用过的值在后面不会再使用。这样，仅仅使用两个变量就可以达到效果，空间复杂度也从O(N)降到了O(1)。123456789101112public class Solution &#123; public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int a =0,b = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int temp = b; b = Math.max(b,a+nums[i]); a = temp; &#125; return b; &#125;&#125; ##题目3一个二维非负数组，找出从最左上到最右下的最小距离，只可以向右或者向下移动。 ###直接寻找递推关系这道题基本是二维中最简单的了，直接看到某一点(i,j)的最短距离怎么求就可以。用二维数组记录到每个点的最短距离dp[i][j]，可以直接根据递推关系 dp[i][j] = min{dp[i-1][j],dp[i][j-1]}就可以求解。 ###二维空间优化一维动态规划可以通过空间优化达到常数级别的空间复杂度，同样二维动态规划也可以进一步优化。首先，根据递归关系，我们发现每个位置只和上面i-1和左边j-1的值有关，于是可以采用数组滚动的方法。在计算第i行的时候，只存储第i－1行的最短距离，比如计算(i,j)点，数组中dp[j]到右边的元素是二维表中（i-1,j)右边的元素。而数组中 dp[j-1]以及其左边的元素，是 二维表中 (i,j-1)及其左边的元素。其实，就是计算将第i行计算过的结果存在数组前半部分，而后半部分是之前计算上一行存储的最短距离，用于以后计算使用。相当于通过滚动，覆盖了不再被需要的值。如下面的简图，其实就是把一个数组分成两半，左边存储dp[i][j-1]所要用的数据，右边是dp[i-1][j]使用的数据。 优化过的代码如下，空间复杂度降到了O(n).1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; //空间压缩，数组滚动方法。 int m = grid.length,n = grid[0].length; int[] dp = new int[n]; dp[0] = grid[0][0]; for(int i=1;i&lt;n;i++) dp[i] =dp[i-1] + grid[0][i]; for(int i=1;i&lt;m;i++) for(int j=0;j&lt;n;j++) dp[j] = (j&gt;0?Math.min(dp[j - 1],dp[j]):dp[j]) + grid[i][j]; return dp[n-1]; &#125;&#125; 题目4、5：这两道题目是一维的动态规划，对于一维的动态规划很难从基本的暴力解法逐步推导过去，更多的是寻找递推关系，类似于钢条切割问题。个人还是比较头疼的。第一个题目：地址：https://leetcode.com/problems/maximum-subarray/题目是在一个数组中，寻找连续的数，获得最大和。比如：[-2,1,-3,4,-1,2,1,-5,4]数组，最大和是子数组[4,-1,2,1]为6。 一维动态规划，寻找递推关系。为了表明是dp问题，设置一个数组，dp[i]表示包含nums[i]的子数组的最大和。从左到右遍历数组，每新添一个数时，计算dp[i］，可以知道新添的数要么和前面最大和子数组累加，得到dp[i]＋nums[i]，要么自己作为一个新的子数组的唯一元素，和是nums[i]，则有递推关系 dp[i] ＝ max(nums[i],dp[i-1] * nums[i])。注意，dp[i]是包含第i个元素的局部最优解，全局最优解每次获得局部最优解比较一下就行。代码如下：123456789101112131415public class Solution &#123; //空间可以被优化 public int maxSubArray(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; int r = nums[0]; dp[0] = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int n = nums[i]; dp[i] = Math.max(n,dp[i-1]+n); r = Math.max(dp[i],r); &#125; return r; &#125;&#125; 第二个题目类似，只不过是乘法最大值。乘法就是要跟踪一下局部的最大值和最小值即可，因为乘法最小值乘以负数也可能出现最大值。代码如下： 1234567891011121314151617181920public class Solution &#123; public int maxProduct(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] max = new int[nums.length]; int[] min = new int[nums.length]; int r = nums[0]; max[0] = r; min[0] = r; for (int i = 1;i&lt;nums.length;i++) &#123; int n = nums[i]; int a = max[i - 1] * n; int b = min[i - 1] * n; max[i] = Math.max(n, Math.max(a,b)); min[i] = Math.min(n, Math.min(a, b)); r = Math.max(max[i], r); &#125; return r; &#125;&#125; 很明显，两个题目都可以优化成O（1）空间，这里为了表示明显不进行优化，读者可以自己尝试一下。","raw":null,"content":null,"categories":[],"tags":[]}]}