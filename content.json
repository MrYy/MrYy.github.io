{"meta":{"title":"Yang Yang的博客","subtitle":null,"description":null,"author":"Yang Yang","url":"http://mryy.com"},"pages":[{"title":"categories","date":"2017-04-19T13:19:02.000Z","updated":"2017-04-19T13:19:02.000Z","comments":true,"path":"categories/index.html","permalink":"http://mryy.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-04-19T13:18:52.000Z","updated":"2017-04-19T13:18:52.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://mryy.com/tags/index-1.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-04-19T13:18:38.000Z","updated":"2017-04-19T13:18:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://mryy.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"android","date":"2017-04-19T12:58:07.000Z","updated":"2017-04-19T12:58:07.000Z","comments":true,"path":"android/index.html","permalink":"http://mryy.com/android/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"EventBus 源码分析","date":"2017-04-19T11:15:03.000Z","updated":"2017-04-19T12:41:57.000Z","comments":true,"path":"android/EventBus-源码分析.html","permalink":"http://mryy.com/android/EventBus-源码分析.html","excerpt":"","text":"EventBusEventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。 register 发布过程register 主要包括两个过程： 找到当前注册的对象中onEvent相关订阅方法 订阅者对找出的方法进行订阅。 findSubscriberMethods利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。 123456789101112131415if (modifierString.length() == 0) &#123; threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123; threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123; threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123; threadMode = ThreadMode.Async; &#125; else &#123; if (skipMethodVerificationForClasses.containsKey(clazz)) &#123; continue; &#125; else &#123; throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method); &#125; &#125; 上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。 subscribe 订阅过程第一阶段找到所有方法后，第二阶段先执行下面的代码： 123for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod, sticky, priority);&#125; subscribe方法主要包含以下过程： 根据EventType找到订阅该事件的订阅队列 找到subsciber订阅的全部事件，并将当前事件添加进去。 处理stick类型的event。 subscriptionsByEventTypeEventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。 123456CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; 上面的代码就获得了某个event对应的订阅队列。然后根据优先级将subscription插入合适的位置。 123456for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125;&#125; typesBySubscriber同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据： 123456List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents);&#125;subscribedEvents.add(eventType); sticky第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。 123456synchronized (stickyEvents) &#123; stickyEvent = stickyEvents.get(eventType);&#125;if (stickyEvent != null) &#123; postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());&#125; post过程currentPostingThreadState虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量： 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; postSingleEvent流程： 将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。 寻找该事件的订阅者，并将事件交给订阅的subscription进行处理： 123synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(clazz); &#125; subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。 12345678910111213141516for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125;&#125; 寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。 第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件： 123456if (!subscriptionFound) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125;&#125; ​ ​ postToSubscriptionEventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单： 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case PostThread: invokeSubscriber(subscription, event); break; case MainThread: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BackgroundThread: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case Async: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况： 直接invokeSubscriber 将subscription和event给到指定的Poster中 invokeSubscriber方法中首先直接反射调用注册该事件的方法： 1subscription.subscriberMethod.method.invoke(subscription.subscriber, event); 从发布到订阅，就这么简单粗暴的完成了。 PosterEventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。 HandlerPoster 如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下： 12345678910PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125;&#125; ​ PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境： 12345678910111213141516171819202122while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125;&#125; handleMessage中流程： 从pendingPostQueue中取出待处理的post，调用相应subscription执行 防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。 总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。 BackgroundPosterHandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。 runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行： 1234567891011121314while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost);&#125; 至此，EventBus的发布订阅模型分析完成。","raw":null,"content":null},{"title":"Android内存泄漏分析实战","date":"2017-04-19T12:52:34.000Z","updated":"2017-04-19T12:52:41.000Z","comments":true,"path":"android/Android内存泄漏分析实战.html","permalink":"http://mryy.com/android/Android内存泄漏分析实战.html","excerpt":"","text":"公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。 #内存泄漏基本概念 内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：1、静态变量持有Activity的context。2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。 #内存检测工具 ##LeakCananry ###使用步骤 LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图： ###整体流程LeakCananry实现步骤大致是：实现大致步骤是：1、自动把activity加入到KeyedWeakReference2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。 ###结论方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。 ##观看整体内存使用情况详情参见官方文档：https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations使用adb shell，进入手机adb，执行命令： 1dumpsys meminfo &lt;包名&gt; [-参数] 可以查看应用不同部分内存分配情况。比如Java heap，Native heap等输出是目前具体应用的内存分配，单位是kilobytes因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。 结果如下： 分析各个参数：Private Clean/Dirty RAM：这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。 PSS Total:我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。 Dalvik Heap：该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。 .so mmap / .dex mmap这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。 上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。 ##DDMS ####使用流程 启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的； 将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”； 链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息； 点击选中想要监测的进程，比如system_process进程； 点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标； 点击Heap视图中的“Cause GC”按钮； 此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。 ####如何检测内存泄漏？Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大 通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。 ##MAT然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。在了解MAT具体使用之前，要先了解一些相关概念。 ####支配树支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。 ####SHALLOWHEAP和RETAINED HEAPShallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：Shallow Size对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。Retained SizeRetained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图： A对象的Retained Size=A对象的Shallow SizeB对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 以上概念，都是在使用MAT进行内存分析经常使用的。我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。 在使用MAT分析内存泄漏的过程中，主要流程就是：1、分析retained heap，找一个使很多对象无法被释放的内存。2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。 ####MAT的下载与使用下载地址：https://eclipse.org/mat/downloads.php这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。首先，在DDMS中选择要检测的进程并dump HPROF file，如下图： HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。 转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。 使用方法：/.hprof-conv.exe a.hprof b.hprofa 是输入hprof文件名，b是输出文件名。然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。如下： ####利用MAT分析内存泄漏分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。 在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。 上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。 Retained heap表示因为这个对象，会导致多少对象无法回收。 右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。outcoming reference就是子节点，查看一些当前对象引用着的对象。 此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。 ##实战分析下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。 ###1、使用DDMS查看内存使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：使用前： 使用后： 通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。 但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。 下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析： ###2、使用MAT分析内存转储前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比： 点击右上角的红色叹号： 对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。再看一下使用前后直方图中的retained heap： 可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。右击直方图中的NewActivity，可以看见如下选项： 用的比较多的是List objects和Merger shortest Paths to GC Roots。List objects：Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。 Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。 在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用： 排除系统的对象，还是主要分析我们编写的程序。 最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。 去掉LeakCanary，再次测试发现data object的值确实下降了不少。 继续分析，发现newActivity引用了一个 致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。接下来，在直方图中过滤出服务端的类：可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。 ##结论在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。","raw":null,"content":null},{"title":"RecyclerView 源码学习及自定义LayoutManager","date":"2017-04-19T12:49:31.000Z","updated":"2017-04-19T12:49:43.000Z","comments":true,"path":"android/RecyclerView-源码学习及自定义LayoutManager.html","permalink":"http://mryy.com/android/RecyclerView-源码学习及自定义LayoutManager.html","excerpt":"","text":"RecyclerView 的三驾马车LayoutManager掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。 measure视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。 layoutlayout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。 在RecyclerView 进行 onMeasure的时候，调用了如下代码： 12345if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec);&#125; else &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);&#125; 如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为 AdapterLayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。 ViewHolderadapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。 ViewHolder构造代码如下： 123456public ViewHolder(View itemView) &#123; if (itemView == null) &#123; throw new IllegalArgumentException(&quot;itemView may not be null&quot;); &#125; this.itemView = itemView;&#125; 其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下： 1234567 public final VH createViewHolder(ViewGroup parent, int viewType) &#123; TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG); final VH holder = onCreateViewHolder(parent, viewType); holder.mItemViewType = viewType; TraceCompat.endSection(); return holder;&#125; 而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。 ViewHolder中的ItemViewItemDecorationItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。 在说明ItemDecoration之前首先要看一下view中draw事件的传递： View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程： 绘制背景 drawBackground 绘制视图内容，即调用自身的 onDraw 绘制child view 使用ItemDecoration，主要通过覆写以下方法： getItemOffsets可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码： onDrawRecyclerView 被父布局调用draw方法，draw方法中关键代码： 12345678public void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ...&#125; 其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有： 1234567public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法： 12345678View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125; #### measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘， 上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。 基本概念RecyclerLayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。 Scrap 或 RecyclerRecycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。 每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。 使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind 小结其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView 自定义LayoutManagergenerateDefaultLayoutParams作用：控制每个item的layoutParams为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp 初始布局 onLayoutChildren这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。 12345if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return;&#125; 这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘： 1234567891011if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2; startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2; interval = 10; detachAndScrapView(scrap, recycler);&#125; 这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘： 12recycler.getViewForPosition(0); addView(scrap); 测绘完成后，再重新放回recycler中，调用 1detachAndScrapView(scrap, recycler); 最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用 1detachAndScrapAttachedViews(recycler); 然后就可以进行layoutChildren的过程了。 先来一个简单的，如下： 123456789int left = 100, top = 0; for (int i = 0; i&lt; getItemCount(); i++) &#123; if (outOfRange(top)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight); top += mDecoratedChildHeight + interval; &#125; 基本效果就是这样： 处理滑动 canScroll 和 scrollXXXBy基本的布局有了之后，就可以处理滑动了。RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法： 关键代码如下： 123456789101112131415161718 final boolean canScrollHorizontally = mLayout.canScrollHorizontally(); final boolean canScrollVertically = mLayout.canScrollVertically(); ... case MotionEvent.ACTION_MOVE: ... if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123; mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1); startScroll = true; &#125;if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123; mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1); startScroll = true; &#125; ...if (startScroll) &#123; setScrollState(SCROLL_STATE_DRAGGING); &#125; ...return mScrollState == SCROLL_STATE_DRAGGING; 这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。比如我们要允许竖直方向的滑动，直接重写如下： 1234@Overridepublic boolean canScrollVertically() &#123; return true;&#125; 再来看一下事件拦截以后，在onTouchEvent中怎么处理的： 123456if (scrollByInternal( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, vtev)) &#123;getParent().requestDisallowInterceptTouchEvent(true); &#125; 代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法： 12345678if (x != 0) &#123; consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState); unconsumedX = x - consumedX;&#125;if (y != 0) &#123; consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState); unconsumedY = y - consumedY;&#125; 就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。 除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子： 1234@Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; return 0; &#125; 返回0的时候，无论怎样都会小于传入的dy，看一下效果： 可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。 分析到这里，基本可以确定如何添加滚动效果了，关键在两点： canScrollXXX中返回true 在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。 为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。 首先，用一个全局变量 List offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化： 1234for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval;&#125; 滑动方面的方法： 1234567@Overridepublic int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; layoutItems(recycler, state, dy); return willScroll;&#125; 并且，原先对item的layout的过程也要进行一些修改： 12345678910111213141516171819202122private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125;&#125; 上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。到此为止，就有了滑动的动画效果： 缩放效果经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。 实现的思路也比较简单，定一条基准线middle如下： 在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。 新的layoutItems代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125;&#125; 最后可以得到下面这样一个比较粗糙的效果： 最后，来贴一下完整的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package rouchuan.circlelayoutmanager;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * Created by yangyang on 2017/3/13. */public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123; private int mDecoratedChildWidth; private int mDecoratedChildHeight; private int interval; private int middle; private int offset; private List&lt;Integer&gt; offsetList; public SimpleLayoutManager(Context context) &#123; offsetList = new ArrayList&lt;&gt;(); &#125; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return; &#125; //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的 if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); interval = 10; middle = (getVerticalSpace() - mDecoratedChildHeight) / 2; detachAndScrapView(scrap, recycler); &#125; //回收全部attach 的 view 到 recycler 并重新排列 int property = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval; &#125; detachAndScrapAttachedViews(recycler); layoutItems(recycler, state, 0); &#125; @Override public boolean canScrollVertically() &#123; return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0; layoutItems(recycler, state, dy); return willScroll; &#125; private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125; &#125; private boolean outOfRange(float targetOffSet) &#123; return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight || targetOffSet &lt; -mDecoratedChildHeight; &#125; private int getHorizontalSpace() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125; private int getVerticalSpace() &#123; return getHeight() - getPaddingTop() - getPaddingBottom(); &#125;&#125;","raw":null,"content":null}],"posts":[{"title":"EventBus 源码分析","slug":"EventBus-源码分析","date":"2017-04-19T11:15:03.000Z","updated":"2017-04-19T12:41:57.000Z","comments":true,"path":"2017/04/19/EventBus-源码分析/","link":"","permalink":"http://mryy.com/2017/04/19/EventBus-源码分析/","excerpt":"","text":"EventBusEventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。 register 发布过程register 主要包括两个过程： 找到当前注册的对象中onEvent相关订阅方法 订阅者对找出的方法进行订阅。 findSubscriberMethods利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。 123456789101112131415if (modifierString.length() == 0) &#123; threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123; threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123; threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123; threadMode = ThreadMode.Async; &#125; else &#123; if (skipMethodVerificationForClasses.containsKey(clazz)) &#123; continue; &#125; else &#123; throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method); &#125; &#125; 上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。 subscribe 订阅过程第一阶段找到所有方法后，第二阶段先执行下面的代码： 123for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod, sticky, priority);&#125; subscribe方法主要包含以下过程： 根据EventType找到订阅该事件的订阅队列 找到subsciber订阅的全部事件，并将当前事件添加进去。 处理stick类型的event。 subscriptionsByEventTypeEventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。 123456CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; 上面的代码就获得了某个event对应的订阅队列。然后根据优先级将subscription插入合适的位置。 123456for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125;&#125; typesBySubscriber同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据： 123456List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents);&#125;subscribedEvents.add(eventType); sticky第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。 123456synchronized (stickyEvents) &#123; stickyEvent = stickyEvents.get(eventType);&#125;if (stickyEvent != null) &#123; postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());&#125; post过程currentPostingThreadState虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量： 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; postSingleEvent流程： 将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。 寻找该事件的订阅者，并将事件交给订阅的subscription进行处理： 123synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(clazz); &#125; subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。 12345678910111213141516for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125;&#125; 寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。 第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件： 123456if (!subscriptionFound) &#123; Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass); if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125;&#125; ​ ​ postToSubscriptionEventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单： 1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case PostThread: invokeSubscriber(subscription, event); break; case MainThread: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BackgroundThread: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case Async: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况： 直接invokeSubscriber 将subscription和event给到指定的Poster中 invokeSubscriber方法中首先直接反射调用注册该事件的方法： 1subscription.subscriberMethod.method.invoke(subscription.subscriber, event); 从发布到订阅，就这么简单粗暴的完成了。 PosterEventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。 HandlerPoster 如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下： 12345678910PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125;&#125; ​ PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境： 12345678910111213141516171819202122while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125;&#125; handleMessage中流程： 从pendingPostQueue中取出待处理的post，调用相应subscription执行 防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。 总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。 BackgroundPosterHandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。 runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行： 1234567891011121314while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost);&#125; 至此，EventBus的发布订阅模型分析完成。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"RecyclerView 源码学习及自定义LayoutManager","slug":"RecyclerView-源码学习及自定义LayoutManager","date":"2017-03-13T15:49:31.000Z","updated":"2017-04-19T13:59:28.000Z","comments":true,"path":"2017/03/13/RecyclerView-源码学习及自定义LayoutManager/","link":"","permalink":"http://mryy.com/2017/03/13/RecyclerView-源码学习及自定义LayoutManager/","excerpt":"","text":"RecyclerView 的三驾马车LayoutManager掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。 measure视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。 layoutlayout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。 在RecyclerView 进行 onMeasure的时候，调用了如下代码： 12345if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec);&#125; else &#123; mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);&#125; 如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为 AdapterLayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。 ViewHolderadapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。 ViewHolder构造代码如下： 123456public ViewHolder(View itemView) &#123; if (itemView == null) &#123; throw new IllegalArgumentException(&quot;itemView may not be null&quot;); &#125; this.itemView = itemView;&#125; 其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下： 1234567 public final VH createViewHolder(ViewGroup parent, int viewType) &#123; TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG); final VH holder = onCreateViewHolder(parent, viewType); holder.mItemViewType = viewType; TraceCompat.endSection(); return holder;&#125; 而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。 ViewHolder中的ItemViewItemDecorationItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。 在说明ItemDecoration之前首先要看一下view中draw事件的传递： View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程： 绘制背景 drawBackground 绘制视图内容，即调用自身的 onDraw 绘制child view 使用ItemDecoration，主要通过覆写以下方法： getItemOffsets可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码： onDrawRecyclerView 被父布局调用draw方法，draw方法中关键代码： 12345678public void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ...&#125; 其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有： 1234567public void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法： 12345678View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125; #### measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘， 上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。 基本概念RecyclerLayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。 Scrap 或 RecyclerRecycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。 每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。 使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind 小结其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView 自定义LayoutManagergenerateDefaultLayoutParams作用：控制每个item的layoutParams为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp 初始布局 onLayoutChildren这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。 12345if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return;&#125; 这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘： 1234567891011if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2; startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2; interval = 10; detachAndScrapView(scrap, recycler);&#125; 这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘： 12recycler.getViewForPosition(0); addView(scrap); 测绘完成后，再重新放回recycler中，调用 1detachAndScrapView(scrap, recycler); 最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用 1detachAndScrapAttachedViews(recycler); 然后就可以进行layoutChildren的过程了。 先来一个简单的，如下： 123456789int left = 100, top = 0; for (int i = 0; i&lt; getItemCount(); i++) &#123; if (outOfRange(top)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); addView(scrap); layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight); top += mDecoratedChildHeight + interval; &#125; 基本效果就是这样： 处理滑动 canScroll 和 scrollXXXBy基本的布局有了之后，就可以处理滑动了。RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法： 关键代码如下： 123456789101112131415161718 final boolean canScrollHorizontally = mLayout.canScrollHorizontally(); final boolean canScrollVertically = mLayout.canScrollVertically(); ... case MotionEvent.ACTION_MOVE: ... if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123; mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1); startScroll = true; &#125;if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123; mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1); startScroll = true; &#125; ...if (startScroll) &#123; setScrollState(SCROLL_STATE_DRAGGING); &#125; ...return mScrollState == SCROLL_STATE_DRAGGING; 这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。比如我们要允许竖直方向的滑动，直接重写如下： 1234@Overridepublic boolean canScrollVertically() &#123; return true;&#125; 再来看一下事件拦截以后，在onTouchEvent中怎么处理的： 123456if (scrollByInternal( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, vtev)) &#123;getParent().requestDisallowInterceptTouchEvent(true); &#125; 代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法： 12345678if (x != 0) &#123; consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState); unconsumedX = x - consumedX;&#125;if (y != 0) &#123; consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState); unconsumedY = y - consumedY;&#125; 就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。 除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子： 1234@Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; return 0; &#125; 返回0的时候，无论怎样都会小于传入的dy，看一下效果： 可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。 分析到这里，基本可以确定如何添加滚动效果了，关键在两点： canScrollXXX中返回true 在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。 为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。 首先，用一个全局变量 List offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化： 1234for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval;&#125; 滑动方面的方法： 1234567@Overridepublic int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; layoutItems(recycler, state, dy); return willScroll;&#125; 并且，原先对item的layout的过程也要进行一些修改： 12345678910111213141516171819202122private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125;&#125; 上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。到此为止，就有了滑动的动画效果： 缩放效果经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。 实现的思路也比较简单，定一条基准线middle如下： 在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。 新的layoutItems代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125;&#125; 最后可以得到下面这样一个比较粗糙的效果： 最后，来贴一下完整的代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package rouchuan.circlelayoutmanager;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * Created by yangyang on 2017/3/13. */public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123; private int mDecoratedChildWidth; private int mDecoratedChildHeight; private int interval; private int middle; private int offset; private List&lt;Integer&gt; offsetList; public SimpleLayoutManager(Context context) &#123; offsetList = new ArrayList&lt;&gt;(); &#125; @Override public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123; return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; if (getItemCount() == 0) &#123; offset = 0; detachAndScrapAttachedViews(recycler); return; &#125; //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的 if (getChildCount() == 0) &#123; View scrap = recycler.getViewForPosition(0); addView(scrap); measureChildWithMargins(scrap, 0, 0); mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap); mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap); interval = 10; middle = (getVerticalSpace() - mDecoratedChildHeight) / 2; detachAndScrapView(scrap, recycler); &#125; //回收全部attach 的 view 到 recycler 并重新排列 int property = 0; for (int i = 0; i &lt; getItemCount(); i++) &#123; offsetList.add(property); property += mDecoratedChildHeight + interval; &#125; detachAndScrapAttachedViews(recycler); layoutItems(recycler, state, 0); &#125; @Override public boolean canScrollVertically() &#123; return true; &#125; @Override public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123; int willScroll = dy; offset += willScroll; if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0; layoutItems(recycler, state, dy); return willScroll; &#125; private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; View view = getChildAt(i); int pos = getPosition(view); if (outOfRange(offsetList.get(pos) - offset)) &#123; removeAndRecycleView(view, recycler); &#125; &#125; detachAndScrapAttachedViews(recycler); int left = 100; View selectedView = null; float maxScale = Float.MIN_VALUE; for (int i = 0; i&lt; getItemCount(); i++) &#123; int top = offsetList.get(i); if (outOfRange(top - offset)) continue; View scrap = recycler.getViewForPosition(i); measureChildWithMargins(scrap, 0, 0); if (dy &gt;= 0) addView(scrap); else addView(scrap, 0); int deltaY = Math.abs(top - offset - middle); scrap.setScaleX(1); scrap.setScaleY(1); float scale = 1 + (mDecoratedChildHeight / (deltaY + 1)); if (scale &gt; maxScale) &#123; maxScale = scale; selectedView = scrap; &#125; layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight); &#125; if (selectedView != null) &#123; maxScale = maxScale &gt; 2 ? 2 : maxScale; selectedView.setScaleX(maxScale); selectedView.setScaleY(maxScale); &#125; &#125; private boolean outOfRange(float targetOffSet) &#123; return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight || targetOffSet &lt; -mDecoratedChildHeight; &#125; private int getHorizontalSpace() &#123; return getWidth() - getPaddingLeft() - getPaddingRight(); &#125; private int getVerticalSpace() &#123; return getHeight() - getPaddingTop() - getPaddingBottom(); &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"JVM垃圾回收知识总结","slug":"JVM垃圾回收知识总结","date":"2017-01-19T02:01:42.000Z","updated":"2017-04-20T02:03:25.000Z","comments":true,"path":"2017/01/19/JVM垃圾回收知识总结/","link":"","permalink":"http://mryy.com/2017/01/19/JVM垃圾回收知识总结/","excerpt":"","text":"##前言java文件被jvm编译成.class文件，.class文件中全部是二进制的数据。在JVM中用一个8bit的变量类型存储指令，这样0到255可以表示总共256个指令。我们编写的代码被编译成相应的指令码交给计算机执行，而在对代码进行调优的时候，可以读懂编译后的.class文件也是很重要的。 ##基础知识 ###Java内存模型首先要先了解一下Java的内存模型，我们比较关心的主要有四个部分：堆，虚拟机栈，本地方法栈，方法区。堆一般存放对象实例，也就是我们new 分配的对象，堆中依据对象存活时间分为新生代和老年代，新生代中又分为Eden空间和Survivor空间（主要是执行复制回收算法时使用的空间），新生代的Survivor空间又分成from空间和to空间。这里简单介绍一下新生代中发生垃圾回收的过程：新生代生成对象的时候，首先分配在Eden区，当Eden区满了以后，执行复制清除算法，将Eden区的对象复制到From然后清除Edne区。这样下一轮时，可以继续在Eden区中分配，Eden和From区是目前存活的对象，当Eden再次满了以后，下一次MinorGC（针对新生代的GC，MajorGC针对老年代，FullGC针对全部）会将Eden和From复制到To中并清除原来的内容，以此类推。如果存活的对象太多导致Survivor区域无法容纳，还需要老年代进行分配担保，将无法保存在Survivor中的对象直接晋升到老年代。方法区主要存放一些静态变量，类信息等，通常我们可以把这部分看作永久代，因为其中分配的对象不会被垃圾收集。运行时常量池是class文件中每一个类或者接口的常量表，包含了字面量和符号饮用，充当一个符号表的作用。比如Java中的字符串，默认声明其实作为字面量存储在常量池中的，参考如下代码： 12345String a = &quot;abc&quot;; String b = &quot;abc&quot;; String c = new String(&quot;abc&quot;); System.out.println(a == b); System.out.println(a == c); 代码中，a==b返回true，a==c返回false，这是因为默认a和b的声明方式实际是在常量池中声明一个符号，然后a和b都指向那个符号”abc”，而c是在堆中声明了一个char数组。java中==默认判断的是两个值地址是否相等，所以第一个返回true，第二个返回false。前面提到，常量池相当于一个符号表。我们可以把它看作一个表结构，键是常量地址，值就是存储的值。如下： 而符号引用，其实就是指类和接口的全限定名和方法的描述符，熟悉jni的话会比较清楚这些东西。简单来讲，在一个实例中可能有另一个对象的引用，那么在class文件中其实存放的是符号引用，也就是java/lang/object 这种字符串，而不是真正的指向内存地址的引用。在动态链接的过程，才会把class文件中这些“假的”符号饮用转换成真正的直接引用（也就是指向一个内存地址）。本地方法栈就是通过Jni调用底层方法的时候，本地C/C++代码执行时候的方法栈。虚拟机栈就是我们的Java代码执行的栈了，也是本文的重点。￼ ###Java虚拟机栈 ####栈帧当一个方法被调用的时候，就进入它所在的方法栈，栈帧随着方法的创建而创建，随着方法的结束而销毁。每一个栈帧都拥有自己的本地变量表，操作数栈和运行时常量池的引用。 ####局部变量表局部变量表中用slot来进行存储，一个slot可以存放一个boolean、byte、char、short、int、float、reference或returnAddress的数据，两个slot可以存储一个long或double。 ####操作数栈每个栈帧中有一个操作数栈，用来存放指令执行的中间结果。有点类似于一个栈实现的计算器。比如当我们执行一个iadd指令中，则要求操作数栈顶是两个int类型的数值，执行iadd后会把两个数值取出来求和再把结果放回操作数栈中。 ###基本指令集.class文件是二进制文件，严格规定了每个字节的含义。是一组以8位字节为基础单位的二进制流，所以又叫字节码。只有两种数据类型：无符号数和表。无符号数可以存放数字、索引引用或者UTF－8编码构成的字符串值。表是无符号数和其他表构成的符合数据类型。指令码由一个字节表示，不同的数字0到200多代表不同的指令。当然在分析的时候，我们一般使用javap -verbose 命令对class文件进行反编译，可以得到相应的明文指令，避免了我们对字节码参照JVM规范手册人工去翻译。所以我们主要关注的是一些指令的具体含义。 ####加载和存储指令 将一个本地变量加载到操作数栈：load相关指令，比如iload加载int类型，fload加载float类型等 将数值从操作数栈加载到本地变量表：store相关指令 加载常量到操作数栈：push、const相关指令对于一些指令，比如iload_1,iload_2就是将操作数隐藏在指令中，就等同于iload 1，iload 2.此外，需要说明，iconst n是把常量n压入操作数栈，istore n 是把操作数栈顶的数存在本地变量表第n个位置，iload n是把本地变量表第n个元素压入操作数栈，本地变量表可以看作一个ArrayList链表数据结构。 可以看到在栈帧中，对于变量的操作流程，基本就是把值从常量池拿到操作数栈，要存储的话就放在本地变量表，要计算了再拿到操作数栈，然后调用相应的指令进行计算。 ####算数指令算数指令用于两个操作数栈上的值进行特定运算，并把计算结果压入操作数栈。比如add，sub，mul，div相关。 ####方法调用和返回指令invokevirtual用于调用实例方法，invokespecial用于调用一些特殊实例方法，比如构造方法，invokestatic用于调用静态方法。返回指令即return相关，比如ireturn。 ####其余指令其余指令包括类型转换指令，对象创建与操作指令，操作数栈管理指令和控制转移指令，在这里不详细介绍可以查阅Java虚拟机规范。 ##实例下面介绍一个工程实例，Java代码如下： 1234567891011public class Main &#123; public int cal() &#123; int a = 1; int b = 1; return a + b; &#125; public int getInteger() &#123; Random random = new Random(); return random.nextInt(5); &#125;&#125; 利用javap -verbose命令对class文件进行反编译，查看字节码：反编译后，生成的字节码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#24 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Class #25 // java/util/Random #3 = Methodref #2.#24 // java/util/Random.&quot;&lt;init&gt;&quot;:()V #4 = Methodref #2.#26 // java/util/Random.nextInt:(I)I #5 = Class #27 // Main #6 = Class #28 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 LMain; #14 = Utf8 cal #15 = Utf8 ()I #16 = Utf8 a #17 = Utf8 I #18 = Utf8 b #19 = Utf8 getInteger #20 = Utf8 random #21 = Utf8 Ljava/util/Random; #22 = Utf8 SourceFile #23 = Utf8 Main.java #24 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #25 = Utf8 java/util/Random #26 = NameAndType #29:#30 // nextInt:(I)I #27 = Utf8 Main #28 = Utf8 java/lang/Object #29 = Utf8 nextInt #30 = Utf8 (I)I&#123; public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this LMain; public int cal(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: iconst_1 1: istore_1 2: iconst_1 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: ireturn LineNumberTable: line 6: 0 line 7: 2 line 8: 4 LocalVariableTable: Start Length Slot Name Signature 0 8 0 this LMain; 2 6 1 a I 4 4 2 b I public int getInteger(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=1 0: new #2 // class java/util/Random 3: dup 4: invokespecial #3 // Method java/util/Random.&quot;&lt;init&gt;&quot;:()V 7: astore_1 8: aload_1 9: iconst_5 10: invokevirtual #4 // Method java/util/Random.nextInt:(I)I 13: ireturn LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 14 0 this LMain; 8 6 1 random Ljava/util/Random;&#125;SourceFile: &quot;Main.java&quot; 下面开始分析主要部分： ###运行时常量池Constant pool 就是前面提到的运行时常量池，类似一个符号表，前面表示在常量池中的地址，后面的字段就是相应的值，同时Javap还会帮助我们生成一些字段辅助查看： #1 = Methodref #6.#24 // java/lang/Object.”“:()V #2 = Class #25 // java/util/Random #25 = Utf8 java/util/Random #26 = NameAndType #29:#30 // nextInt:(I)I 在我们class文件的常量池中有四种类型的常量，Utf8就是字面常量，一个字符串。而Methodref是一个方法的符号引用，为什么说是符号引用呢，就是因为最后看到它其实就是一个方法描述符：字符串而已。同时，Class表示引用到的一个类，NameAndType表示一个字段或者方法。 Code属性下面是方法的描述符标志位等信息，然后是最重要的信息：code属性。分析其中的cal方法： 123456789101112131415public int cal(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 ... LineNumberTable: line 6: 0 line 7: 2 line 8: 4 LocalVariableTable: Start Length Slot Name Signature 0 8 0 this LMain; 2 6 1 a I 4 4 2 b I stack ＝ 2表明操作数栈最大深度是2，locals＝3是本地变量表最大数目为3，args_size ＝ 1，是因为该方法是实例方法，所以默认有一个输入参数this，指向方法所在的实例。下面的LineNumberTable表示java源代码和字节码的对应关系，用于堆栈跟踪。LocalVariableTable描述局部变量表中的变量和Java源代码定义变量的对应关系。其中start代表局部变量声明开始，length表示在字节码中存活的长度，结合起来就是作用域范围。参考下面的指令码：this在一开始就声明，时间限定为0，变量a在第二个时刻 istore_1存入局部变量表，所以start的值就是2，b在第四个时刻存入，所以start是4，声明周期可以依次推理。 123456780: iconst_11: istore_12: iconst_13: istore_24: iload_15: iload_26: iadd7: ireturn 再来简单分析一下指令，结合前面提高的指令介绍：iconst_1，将常数1加载到操作数栈，istore_1将1从操作数栈栈顶元素1存储到局部变量表第一个位置，下面的2，3条指令同理。iload_1把局部变量表第一个元素加入操作数栈，iload_2同理，现在操作数栈有两个元素 1、1，然后iadd取出栈顶两个元素相加，ireturn返回。 ##总结基本内容就是这些，对于字节码的学习，更详细的内容可以参考Java虚拟机规范。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Android内存泄漏分析实战","slug":"Android内存泄漏分析实战","date":"2016-12-21T12:52:34.000Z","updated":"2017-04-19T14:00:33.000Z","comments":true,"path":"2016/12/21/Android内存泄漏分析实战/","link":"","permalink":"http://mryy.com/2016/12/21/Android内存泄漏分析实战/","excerpt":"","text":"公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。 #内存泄漏基本概念 内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：1、静态变量持有Activity的context。2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。 #内存检测工具 ##LeakCananry ###使用步骤 LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图： ###整体流程LeakCananry实现步骤大致是：实现大致步骤是：1、自动把activity加入到KeyedWeakReference2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。 ###结论方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。 ##观看整体内存使用情况详情参见官方文档：https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations使用adb shell，进入手机adb，执行命令： 1dumpsys meminfo &lt;包名&gt; [-参数] 可以查看应用不同部分内存分配情况。比如Java heap，Native heap等输出是目前具体应用的内存分配，单位是kilobytes因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。 结果如下： 分析各个参数：Private Clean/Dirty RAM：这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。 PSS Total:我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。 Dalvik Heap：该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。 .so mmap / .dex mmap这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。 上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。 ##DDMS ####使用流程 启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的； 将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”； 链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息； 点击选中想要监测的进程，比如system_process进程； 点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标； 点击Heap视图中的“Cause GC”按钮； 此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。 ####如何检测内存泄漏？Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大 通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。 ##MAT然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。在了解MAT具体使用之前，要先了解一些相关概念。 ####支配树支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。 ####SHALLOWHEAP和RETAINED HEAPShallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：Shallow Size对象自身占用的内存大小，不包括它引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。Retained SizeRetained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图： A对象的Retained Size=A对象的Shallow SizeB对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 以上概念，都是在使用MAT进行内存分析经常使用的。我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。 在使用MAT分析内存泄漏的过程中，主要流程就是：1、分析retained heap，找一个使很多对象无法被释放的内存。2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。 ####MAT的下载与使用下载地址：https://eclipse.org/mat/downloads.php这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。首先，在DDMS中选择要检测的进程并dump HPROF file，如下图： HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。 转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。 使用方法：/.hprof-conv.exe a.hprof b.hprofa 是输入hprof文件名，b是输出文件名。然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。如下： ####利用MAT分析内存泄漏分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。 在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。 上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。 Retained heap表示因为这个对象，会导致多少对象无法回收。 右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。outcoming reference就是子节点，查看一些当前对象引用着的对象。 此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。 ##实战分析下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。 ###1、使用DDMS查看内存使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：使用前： 使用后： 通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。 但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。 下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析： ###2、使用MAT分析内存转储前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比： 点击右上角的红色叹号： 对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。再看一下使用前后直方图中的retained heap： 可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。右击直方图中的NewActivity，可以看见如下选项： 用的比较多的是List objects和Merger shortest Paths to GC Roots。List objects：Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。 Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。 在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用： 排除系统的对象，还是主要分析我们编写的程序。 最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。 去掉LeakCanary，再次测试发现data object的值确实下降了不少。 继续分析，发现newActivity引用了一个 致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。接下来，在直方图中过滤出服务端的类：可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。 ##结论在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"KMP算法小探","slug":"KMP算法小探","date":"2016-12-20T15:08:49.000Z","updated":"2017-04-20T02:10:43.000Z","comments":true,"path":"2016/12/20/KMP算法小探/","link":"","permalink":"http://mryy.com/2016/12/20/KMP算法小探/","excerpt":"","text":"KMP算法题解题目是leetcode上的Implement strStr()，题目大意就是在字符串haystack中寻找字符串needle的是否存在，并返回位置。地址是：https://leetcode.com/problems/implement-strstr/，可以用来训练一下KMP算法的实现。 学习KMP算法的过程中，参考了这篇文章：http://blog.csdn.net/yutianzuijin/article/details/11954939/ KMP算法的核心原理在于：传统的字符串匹配，一旦发生失配，那么模式字符串直接回退到最开始。但是在KMP算法中，我们根据模式字符串的特征，在失配的时候，根据已有信息尽可能少的回退。 这个信息就是：模式字符串的最长公共前后缀。比如说一个长度为4的字符串abab，那么最长公共前后缀就是ab，从左边数有个ab，右边也有个ab，长度为2。一旦匹配到最右边的b后发生失配，比如模式：ababc，文本：ababd，因为模式长度为4的部分左右对称，所以不需要全部回退，回退到左边的ab即可。这个信息也就是存在最长公共前后缀中，我们用一个next数组来表示。比如next[4] = 2，就是长度为2的字符串最长前后缀值为2，于是回退到2即可，也就是ab后的下一个字符。 next数组计算方法：引用参考文章中的说明： next数组计算理解了kmp算法的基本原理，下一步就是要获得字符串f每一个位置的最大公共长度。这个最大公共长度在算法导论里面被记为next数组。在这里要注意一点，next数组表示的是长度，下标从1开始；但是在遍历原字符串时，下标还是从0开始。假设我们现在已经求得next[1]、next[2]、……next[i]，分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要求next[i+1]。由上图我们可以看到，如果位置i和位置next[i]处的两个字符相同（下标从零开始），则next[i+1]等于next[i]加1。如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度next[next[i]]，然后再和位置i的字符比较。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为next[next[i]]的字符串，直到字符串长度为0为止。由此我们可以写出求next数组的代码（Java版）： 123456789101112131415public int[] getNext(String b)&#123; int len=b.length(); int j=0; int next[]=new int[len+1];//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始 next[0]=next[1]=0; for(int i=1;i&lt;len;i++)//i表示字符串的下标，从0开始 &#123; //j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置。 这句注释一定要结合上面的说明理解，理解了KMP算法基本也就搞定了。 while(j&gt;0&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j]; if(b.charAt(i)==b.charAt(j))j++; next[i+1]=j; &#125; return next;&#125; 这份代码中比较难理解的就是while循环，再举一个例子，比如模式字符串：ababeababc，当我们计算了前九个字符，有next[9] = 4，也就是前9字符最长公共缀为abab。（注意next[9]表明字符串长度，而4是索引，也就是第五个字符，这块有点绕要注意理解）那么现在开始计算next[10]，可以看到 j = next[9] = 4,string[4] != string[9]，看这个时候next[4]是什么，是左边abab字符串的最长公共缀ab！由于abab中左右ab是对称的，这个时候最左边的ab加上一个a，和最右边的ab加上string[9]也就是c，有可能组成新的更长的公共前缀（当然本例中a!=c，所以不存在，继续拆分）。这就是计算next的精髓，通过j=next[j]加速寻找。因为要的到更长的最长公共缀，那么i之前和j之前的字符串必须是对应的。再举个例子 dabdabcdabdabd 123456 d a b d a b c d a b d a b d j i ，i和j处字符不同，回退 j i ,回退到next[j］，字符相同 d a b d d a b d ,生成公共缀next[i+1]=j。可以看到，左边和右边除了i，j位置外用到的字符串，实际上是d a b d a b 的最长公共缀 d a b，如果没有回退到next[j]，即使i和j字符相同，剩余的部分也无法匹配。 有点类似于一个递归的过程，只不过在递归过程中，我们不断移动j指针，使它指向可能存在结果的最长公共前缀的下一个字符，并和当前处理到的字符对比，来计算出新的next值 本题解： 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length() == 0) return 0; int[] next = getNext(needle); int i = 0, j = 0; while(i&lt;haystack.length()&amp;&amp; j &lt; needle.length())&#123; if(haystack.charAt(i) == needle.charAt(j))&#123; i++; j++; &#125;else&#123; if(j != 0)&#123; j = next[j]; &#125;else &#123; i++; &#125; &#125; &#125; if(j == needle.length()) return i - needle.length(); else return -1; &#125; public int[] getNext(String b) &#123; int len=b.length(); int j=0; int next[]=new int[len+1]; next[0]=next[1]=0; for(int i=1;i&lt;len;i++) &#123; while(j&gt;0&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j]; if(b.charAt(i)==b.charAt(j))j++; next[i+1]=j; &#125; return next; &#125;&#125; KMP 算法两种写法KMP算法可以用来匹配模式字符串，或者寻找最小重复单元，比如abcabcabc，最小重复单元就是abc。qweqweqwe，最小重复单元是qwe。寻找最小重复单元就是计算出字符串的最长公共前缀的长度a，如果 a != 0 &amp;&amp; len %(len-a) == 0即找到最小重复单元。 详细内容见KMP算法核心在于next数组的计算，因此列出getNext的不同计算方法。 1、next[i]表示长度为i的字符串最长公共前缀值123456789101112131415public int[] getNext(String b) &#123; int len=b.length(); int j=0; int next[]=new int[len+1];//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始 next[0]=next[1]=0; for(int i=1;i&lt;len;i++)//i表示字符串的下标，从0开始 &#123; //j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置。 这句注释一定要结合上面的说明理解，理解了KMP算法基本也就搞定了。 while(j&gt;0&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j]; if(b.charAt(i)==b.charAt(j))j++; next[i+1]=j; &#125; return next; &#125; ##2、next[i]表示字符串[0,i]，即下标。123456789private void getNext(String s) &#123; int[] next = new int[s.length()]; int i = 1,j = 0; while (i &lt; s.length()) &#123; if (s.charAt(i) == s.charAt(j)) next[i++] = ++j; else if (j == 0) next[i++] = 0; else j = next[j - 1]; &#125;&#125; 第二种下标的写法比较简洁，next[i]表示字符串 [0,i]的最长公共缀。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"二叉树常见问题整理","slug":"二叉树常见问题整理","date":"2016-11-20T15:11:29.000Z","updated":"2017-04-20T02:12:08.000Z","comments":true,"path":"2016/11/20/二叉树常见问题整理/","link":"","permalink":"http://mryy.com/2016/11/20/二叉树常见问题整理/","excerpt":"","text":"做leetcode二叉树的题目做了不少，觉得有必要总结一下。因为题型多归多，但其实无非就是dfs和bfs，总结一些常见的解法，对于加深这两周算法的理解很有帮助。在做dfs的时候，主要思路是可以从上到下也可以从下到上，也就是分析每一个子树的根节点，然后分析该子树的内部子树或者外部子树的根节点，以此得出递归关系，也即是分治的思想。同时，对于每个节点的处理尝试利用前序、后序、中序遍历三种方法。做bfs的时候，主要思路是从上到下，一层一层进行分析。 ##构建二叉树leetcode 105和106题 1、利用前序和中序遍历构建二叉树。构建一棵二叉树，如果是通过dfs的方式的话，那么分析每一个子树的根节点，将一个大子树分解成一个一个小的子树，分治下去，也就可以得出递归。比如，有前序1，2，4，5，3，中序4，2，5，1，3。从前序中，我们可以得出一个条件：当前子树的根节点。对于整个子树1，2，4，5，3，可以确定，1是该子树根节点，然后去中序中找1，1的左边是4，2，5，右边是3。因为中序的性质是在遍历完左子树后遍历当前根节点，所以说4，2，5就是1为父节点的一个新的子树。去前序中得到一个新的前序+中序数组对：2，4，5； 4，2，5，同理，2是该子树根节点，4是左子树，5在右子树， 以此类推分治递归下去。找到递归关系后，每一层根节点完成当前任务，然后将构建子树的任务交给左右子树递归过程即可。同时，我们思考的过程是从上到下，但程序递归运行的过程是从下到上，这点需要注意。可以写出代码： 1234567891011121314151617181920TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder.length != inorder.length) return null; if (preorder.length ==0) return null; //完成当前任务，构建当前子树根节点。 TreeNode node = new TreeNode(preorder[0]); if (preorder.length == 1) return node; int root = preorder[0]; int leftCount=0; //找到根节点位置 for (int i =0;i&lt;inorder.length;i++) &#123; if (inorder[i] == root)&#123; leftCount = i; break; &#125; &#125; //将新的构建任务递归交下去。 node.left = buildTree(Arrays.copyOfRange(preorder, 1, leftCount+1),Arrays.copyOfRange(inorder,0,leftCount)); node.right = buildTree(Arrays.copyOfRange(preorder, leftCount + 1, preorder.length ), Arrays.copyOfRange(inorder, leftCount + 1, inorder.length )); return node; &#125; 2、利用后序和中序构建二叉树。思路类似，还是先找根节点！可以看到，当前整个子树根节点可以通过后续确定，然后利用中序确定左右子树来分治递归。思路类似。 ##构建二叉搜索树 BSTleetcode 108和109题 1、通过有序数组来构建一棵平衡二叉搜索树。 首先，对于一个有序数组，比如1，2，3，4，5，6。这里采用dfs解题。前面说过分析dfs时针对每一个子树的根节点，通过各个子树的根节点来寻找递归关系。对于BST最上面的子树，根节点就是有序数组最中间的元素，令s = 0，e = 5，那么mid = s +(e-s)/2 = 2。也就是3是整个子树根节点，1，2是左子树内容，4，5，6是右子树内容。对于1，2有s = 0，e = 1，同理mid = 0，也就是1是该子树根节点，2是右子树内容。 以此类推很容易写出递归： 12345678TreeNode dfs(int s,int e,int[] nums)&#123; if(s &gt; e) return null; int mid = s + (e-s)/2; TreeNode root = new TreeNode(nums[mid]); root.left = dfs(s,mid-1,nums); root.right = dfs(mid+1,e,nums); return root;&#125; 这里，建议画出递归栈，方便理解。在思考递归时，是从上到下思考，由整体到局部，但是程序运行时从下到上的，也就是dfs运行方式。是通过前序遍历的方式，在数组中依次拿出2，1，3，4，5，从下到上构建出BST，构建顺序是dfs的前序方式。 2、通过有序链表来构建一棵平衡二叉搜索树。链表和数组不同了，数组可以随机访问，而链表只能顺序访问。所以，我们的思路应该是，依次将1，2，3，4，5填到BST的正确位置。利用类似1中的dfs，可以得到下图的递归栈，也就是说这5个符合条件的点就是BST中的点。我们从链表中依次拿出1，2，3，4，5，填入到这个树结构并构造BST。可以看到，对于1，应该填在0-&gt;1的位置，2填在1-&gt;1的位置，然后3填在0-&gt;4，4填在3-&gt;4，其实也就是以中序遍历的顺序填进去。这样一来，代码也就出来了： 1234567891011TreeNode dfs(int s, int e) &#123; if (s &gt; e) return null; int mid = s + (e -s )/2; TreeNode left = dfs(s, mid - 1); TreeNode node = new TreeNode(head.val); head = head.next; TreeNode right = dfs(mid + 1, e); node.left = left; node.right = right; return node;&#125; 可以看到，在构建树或者BST的过程中，找准根节点位置以及填放顺序，来相应处理即可。 ##按层级遍历问题leetcode 102，103，107都是此类问题，此类问题十分简单，可以采用bfs和dfs求解。 将一棵二叉树按层级遍历。如果使用bfs，遍历完一层后可以得到下一次的全部节点数，在每一次遍历后一次性遍历整个一层即可。代码类似： 1234567891011Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();queue.add(root);while(!queue.isEmpty())&#123; int size = queue.size(); //利用for循环，一次性遍历一个层级。 for(int i = 0;i&lt;size;i++)&#123; TreeNode cur = queue.poll(); queue.add(cur.left); queue.add(cur.right); &#125;&#125; 如果使用dfs，我们无法保证一个层级的全部节点是同一时刻遍历的，但是可以分时遍历，也就是在dfs中添加一个关于level的参数，将同一level的点加入到结果中。 1234567dfs(TreeNode root,int level)&#123; if(root == null ) return; //将当前节点添加到结果中 result.get(level).add(root); dfs(root.left,level+1); dfs(root.right,level + 1);&#125; 可以看到，利用level将节点添加到结果链表相应位置，不管是正序，倒叙还是ZigZag，都是相应计算的事，所以还是比较推荐dfs，简单整洁。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"动态规划简介","slug":"动态规划简介","date":"2016-10-29T13:56:31.000Z","updated":"2017-04-19T14:00:12.000Z","comments":true,"path":"2016/10/29/动态规划简介/","link":"","permalink":"http://mryy.com/2016/10/29/动态规划简介/","excerpt":"","text":"动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。 #解题思路在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新的元素和已有结果是否存在某种关系。对于没有思路的题目，求解可以分为暴力递归（回溯），记忆性搜索，递归优化，时间或空间最终优化四个阶段。在碰到一道可以使用动态规划的题目的时候，如果还不知道怎么下手，那么第一步，一定要去想如何递归求解。所谓递归求解，说的简单点，就是一种穷举，文艺一点，也可以叫回溯。是的，在学习动态规划之前，一定要对回溯法有所了解。 123456789101112131415161718backtracking(member)&#123; //如果已经不可能再得到结果，直接返回。也叫剪枝，分支限界。 if(is_invalid) return; //如果得到最终结果，处理显示。 if(is_solution) print_result(); //递归即将进入下一层级，如果有数据在下一层级中需要使用，更新它们。 move_ahead(); //准备要进入递归的元素。 candidate[] candidates = get_candidates; for(candidate in candidates)&#123; backtracking(candidate) &#125; //递归回到当前层级，将数据更新回当前层级所需数据。 move_back();&#125; 上面就是回溯法的基本模板，看清来可能有点模糊，下面的第一道题目的第一个步骤，就将对此作出详细解释。 ##题目1 123给一个非负数组，你一开始处在数组收尾（index=0），数组中元素代表你能从当前位置向后跳的**最大**步数，问能否达到数组末尾。比如：A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. ###递归求解 最为直观的回溯法求解如下：思路十分直观，当我们到了每个位置，在此位置上，可以向后跳1到最大步数，在每一跳之后进行递归，依次类推穷举出所有情况，一旦有一种可以到达最终位置，那么我们就可以得到最终结果。1234567891011121314151617181920public class Solution &#123; public boolean canJumpFromPosition(int position, int[] nums) &#123; if (position == nums.length - 1) &#123; return true; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; return true; &#125; &#125; return false; &#125; public boolean canJump(int[] nums) &#123; return canJumpFromPosition(0, nums); &#125;&#125; 首先先进行一下简单的优化，在每一步判断下一跳位置的时候，为了尽快的到达最后的位置，我们很明显应该尽可能多走步数，一旦发现最后无法到达再减少步数。 1234// 原始代码for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++)// 新的代码for (int nextPosition = furthestJump; nextPosition &gt; position; nextPosition--) ###记忆化搜索（自顶向下动态规划）可以看到，上面的递归基本就是暴力解法，那么进一步的优化，就是在递归上面应用存储，已经计算过的分支不再继续进行计算。 123456789101112131415161718192021222324252627282930public class Solution &#123; Index[] memo; public boolean canJumpFromPosition(int position, int[] nums) &#123; //存储已经计算过的分支 if (memo[position] != Index.UNKNOWN) &#123; return memo[position] == Index.GOOD ? true : false; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; memo[position] = Index.GOOD; return true; &#125; &#125; memo[position] = Index.BAD; return false; &#125; public boolean canJump(int[] nums) &#123; memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; return canJumpFromPosition(0, nums); &#125;&#125; ###去递归（自底向上动态规划）去递归的过程，其实就是人为的分析并指定计算过程的过程。首先分析递归过程中的可变参数，这个可变参数就是循环中遍历的变量。这里很明显是当前位置 position。然后需要分析递归的运行顺序，这里可以人为画递归树。我们可以发现，运算实质是从右向左进行的。一个点能否达到某一个点，取决于它右边点的运算结果。 1234567891011121314151617181920212223242526enum Index &#123; GOOD, BAD, UNKNOWN&#125;public class Solution &#123; public boolean canJump(int[] nums) &#123; Index[] memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; int furthestJump = Math.min(i + nums[i], nums.length - 1); //去当前点的右边看是否有可达点。 for (int j = i + 1; j &lt;= furthestJump; j++) &#123; if (memo[j] == Index.GOOD) &#123; memo[i] = Index.GOOD; break; &#125; &#125; &#125; return memo[0] == Index.GOOD; &#125;&#125; ###贪心优化（贪心策略）上面的时间复杂度为O（mn），m是数组中最大值，n是数组个数。在分析上面循环的过程中，我们发现找到的第一个点可以到达一个可达点，那么当前位置就不需要再判断后面的步数。也就是说，一个点只要找到离他最近的可达点，那么它就变成了下一轮的可达点。下一轮一旦有一个点可以达到它，那么该点又成为下一轮新的可达点。这也就告诉我们，对于每个点，只要找到它右边第一个可达点即可。这也就是典型的贪心策略。我们可以从右向左，在某个可达点左边找一个最近的点可以达到它，更新该最近点为新的可达点，以此类推，知道最后的一个可达点是起始点。 1234567891011public class Solution &#123; public boolean canJump(int[] nums) &#123; int lastPos = nums.length - 1; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (i + nums[i] &gt;= lastPos) &#123; lastPos = i; &#125; &#125; return lastPos == 0; &#125;&#125; ##题目2给一个非负数组，从数组中选取任意个数字求和，要求所选元素均不相邻，求最大和。 ###直接寻找递归关系对于比较简单的dp，也可以寻找递推关系求解：这到题的递推关系在于，对于每一个新的元素，都可以选择取或者不取，用一个数组dp记录前面不同长度数组的最大和，那么对当前元素dp[i]，如果不取则最大和为dp[i-1],如果取则最大值为dp[i-2]+num[i];可以很轻易的根据递推关系写出动态规划： 1234567891011public class Solution &#123; public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length+1]; dp[0] = 0; dp[1] = nums[0]; for(int i = 2;i&lt;nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],nums[i]+dp[i-2]); &#125; return dp[nums.length];&#125; 同经典的钢条切割背包问题一样， 对于一个新出现的元素，选与不选是构成递归的重要策略。比如leetcode两道题目 ：https://leetcode.com/problems/house-robber/，https://leetcode.com/problems/house-robber-ii/，都是对于一个新出现的元素，进行选与不选两种决策去寻找递推关系，动态规划可能的O(N)解法基本也只会出现在这种决策中。 ###空间优化到这里还不算完，我们看见，对于每个dp[i]的计算，仅和dp[i-1]，dp[i-2]有关，这也告诉我们根本不需要一个数组，因为以前用过的值在后面不会再使用。这样，仅仅使用两个变量就可以达到效果，空间复杂度也从O(N)降到了O(1)。123456789101112public class Solution &#123; public int rob(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int a =0,b = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int temp = b; b = Math.max(b,a+nums[i]); a = temp; &#125; return b; &#125;&#125; ##题目3一个二维非负数组，找出从最左上到最右下的最小距离，只可以向右或者向下移动。 ###直接寻找递推关系这道题基本是二维中最简单的了，直接看到某一点(i,j)的最短距离怎么求就可以。用二维数组记录到每个点的最短距离dp[i][j]，可以直接根据递推关系 dp[i][j] = min{dp[i-1][j],dp[i][j-1]}就可以求解。 ###二维空间优化一维动态规划可以通过空间优化达到常数级别的空间复杂度，同样二维动态规划也可以进一步优化。首先，根据递归关系，我们发现每个位置只和上面i-1和左边j-1的值有关，于是可以采用数组滚动的方法。在计算第i行的时候，只存储第i－1行的最短距离，比如计算(i,j)点，数组中dp[j]到右边的元素是二维表中（i-1,j)右边的元素。而数组中 dp[j-1]以及其左边的元素，是 二维表中 (i,j-1)及其左边的元素。其实，就是计算将第i行计算过的结果存在数组前半部分，而后半部分是之前计算上一行存储的最短距离，用于以后计算使用。相当于通过滚动，覆盖了不再被需要的值。如下面的简图，其实就是把一个数组分成两半，左边存储dp[i][j-1]所要用的数据，右边是dp[i-1][j]使用的数据。 优化过的代码如下，空间复杂度降到了O(n).1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; //空间压缩，数组滚动方法。 int m = grid.length,n = grid[0].length; int[] dp = new int[n]; dp[0] = grid[0][0]; for(int i=1;i&lt;n;i++) dp[i] =dp[i-1] + grid[0][i]; for(int i=1;i&lt;m;i++) for(int j=0;j&lt;n;j++) dp[j] = (j&gt;0?Math.min(dp[j - 1],dp[j]):dp[j]) + grid[i][j]; return dp[n-1]; &#125;&#125; 题目4、5：这两道题目是一维的动态规划，对于一维的动态规划很难从基本的暴力解法逐步推导过去，更多的是寻找递推关系，类似于钢条切割问题。个人还是比较头疼的。第一个题目：地址：https://leetcode.com/problems/maximum-subarray/题目是在一个数组中，寻找连续的数，获得最大和。比如：[-2,1,-3,4,-1,2,1,-5,4]数组，最大和是子数组[4,-1,2,1]为6。 一维动态规划，寻找递推关系。为了表明是dp问题，设置一个数组，dp[i]表示包含nums[i]的子数组的最大和。从左到右遍历数组，每新添一个数时，计算dp[i］，可以知道新添的数要么和前面最大和子数组累加，得到dp[i]＋nums[i]，要么自己作为一个新的子数组的唯一元素，和是nums[i]，则有递推关系 dp[i] ＝ max(nums[i],dp[i-1] * nums[i])。注意，dp[i]是包含第i个元素的局部最优解，全局最优解每次获得局部最优解比较一下就行。代码如下：123456789101112131415public class Solution &#123; //空间可以被优化 public int maxSubArray(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[nums.length]; int r = nums[0]; dp[0] = nums[0]; for(int i=1;i&lt;nums.length;i++)&#123; int n = nums[i]; dp[i] = Math.max(n,dp[i-1]+n); r = Math.max(dp[i],r); &#125; return r; &#125;&#125; 第二个题目类似，只不过是乘法最大值。乘法就是要跟踪一下局部的最大值和最小值即可，因为乘法最小值乘以负数也可能出现最大值。代码如下： 1234567891011121314151617181920public class Solution &#123; public int maxProduct(int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int[] max = new int[nums.length]; int[] min = new int[nums.length]; int r = nums[0]; max[0] = r; min[0] = r; for (int i = 1;i&lt;nums.length;i++) &#123; int n = nums[i]; int a = max[i - 1] * n; int b = min[i - 1] * n; max[i] = Math.max(n, Math.max(a,b)); min[i] = Math.min(n, Math.min(a, b)); r = Math.max(max[i], r); &#125; return r; &#125;&#125; 很明显，两个题目都可以优化成O（1）空间，这里为了表示明显不进行优化，读者可以自己尝试一下。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"android 消息系统Handler、Message、Looper","slug":"android-消息系统Handler、Message、Looper","date":"2016-09-20T02:05:34.000Z","updated":"2017-04-20T02:07:04.000Z","comments":true,"path":"2016/09/20/android-消息系统Handler、Message、Looper/","link":"","permalink":"http://mryy.com/2016/09/20/android-消息系统Handler、Message、Looper/","excerpt":"","text":"##android消息系统整体框架如图所示在安卓的消息系统中，每个线程有一个Looper，Looper中有一个MessageQueue，Handler向这个队列中投递Message，Looper循环拿出Message再交由Handler处理。整体是一个生产者消费者模式，这四部分也就构成了android的消息系统。先来看一个最简单的例子 123456789//这段代码在某个Activity的onCreate中 Handler handler = new Handler(Looper.getMainLooper()); Message msg = Message.obtain(handler, new Runnable() &#123; @Override public void run() &#123; Toast.makeText(getApplicationContext,\"I am a message\",Toast.LENGTH_SHORT).show(); &#125; &#125;); handler.sendMessage(msg); 效果就是，在当前窗口弹出I am a message，当然就其实现的效果而言完全多此一举。但是就分析android消息系统，却是很简单有效的例子。 ##源码分析 ###MessageMessage中封装了我们常用的what、arg1、arg2、obj等参数，除此之外还有target：一个Handler类型，由前文可知一个Message最终还是交给一个Handler执行的，这个target存放的就是消息的目的地、callback，一个消息的回调，我们通过handler.post(new Runnable{…})发送的消息，这个Runnable即被存为callback。首先来看消息的获取：1234567891011121314151617181920public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; &#125; &#125; return new Message();&#125;public static Message obtain(Handler h, Runnable callback) &#123; Message m = obtain(); m.target = h; m.callback = callback; return m;&#125; 对照最开始的例子，Message.obtain(Handler h, Runnable callback)首先调用obtain获取了一个新的Message对象，然后为其设置了目的地Handler和回调函数callback，Message类中有很多不同的obtain函数，实际上只是为我们封装了一些赋值的操作。 再看Message.obtain()方法，sPoolSync是一个给静态方法用的静态锁，sPool是一个静态的Message变量，在消息的获取这里，android使用了享元模式，对于会被重复使用的Message消息，没有对每一次请求都新建一个对象，而是通过维护一个Message链表，在有空闲消息的时候从链表中拿Message，没有时才新建Message。可以看到obtain中只有从链表中去Message和新建Message，而没有向链表中存储的过程。存储这部分就要看Message.recycle()了：1234567891011public void recycle() &#123; clearForRecycle(); synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; 回收过程，首先把原链表的头指向当前被回收消息的下一个节点，然后再把链表头指针知道当前节点即可。整个操作也就是将Message添加到链表的首位。 ###MessageQueue 消息队列MessageQueue是在Looper中的，这点从Looper的构造函数可以看出来： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 对于每个MessageQueue，是链表实现的消息队列。首先是入队操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051boolean enqueueMessage(Message msg, long when) &#123; if (msg.isInUse()) &#123; throw new AndroidRuntimeException(msg + \" This message is already in use.\"); &#125; if (msg.target == null) &#123; throw new AndroidRuntimeException(\"Message must have a target.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; RuntimeException e = new RuntimeException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(\"MessageQueue\", e.getMessage(), e); return false; &#125; msg.when = when; //mMessages是链表的头指针 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 将消息插入到队列的首位 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; //当抵达队列尾部、或者当前消息的时间小于队列中某消息的时间跳出循环 if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; //将消息插入到链表中间（包含尾部） msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; next操作，包含取出和删除一条消息。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //从native层消息队列取出消息 nativePollOnce(mPtr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 找到非异步的Message或者消息队列尾部的Message取出 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 消息尚未到执行时间，下次循环挂起线程一段时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一个Message mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // 检查退出标志位 if (mQuitting) &#123; dispose(); return null; &#125; ... &#125; &#125; ###HandlerHandler的作用是放入消息和处理消息，承担了生产者的工作和部分消费者的工作。首先通过Handler发送一条消息：1234567891011121314151617181920212223public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 通过一层一层嵌套，真正的逻辑在sendMessageAtTime，可以看到仅仅是执行了一下入队操作。作为生产者的工作也就执行完成，消费者部分后面要结合Looper分析。除了sendMessage方法，常用的handler.post方法也是封装为Message，主要过程和上面相似。 123456789public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; ###LooperLooper类中，Looper的实例获取是通过ThreadLocal的，ThreadLocal会为每一个线程提供一个副本，通过set和get方法每个线程获取作用域仅属于该线程的变量值。对于UI线程而言，会执行Looper.prepareMainLooper()来完成Looper的初始化：12345678910111213141516public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125; &#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; Looper.prepare()方法将当前线程的ThreadLocal设置了一个新的Looper对象，prepareMainLooper则是把当前线程的Looper对象赋值给类变量sMainLooper ，该方法在ActivityThread中调用，设置了一个全局的给UI线程使用的Looper。 Looper的loop方法就是消费者的处理逻辑了： 12345678910111213141516171819202122232425public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //从Looper中获取MessageQueue，循环取出消息 for (;;) &#123; Message msg = queue.next(); ... //将消息发送给目标处理。 msg.target.dispatchMessage(msg); ... //回收消息，把消息放在消息池中 msg.recycle(); &#125; &#125; 主要逻辑很清晰，前面分析过msg.target是一个Handler，表示处理消息的目标，通过命令模式将消息交给对应Handler处理。下面是Handler中处理消息的方法：1234567891011121314151617public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125;private static void handleCallback(Message message) &#123; message.callback.run(); &#125;public void handleMessage(Message msg) &#123; &#125; 如果我们是通过handler.post的方法发送一条消息，那么直接执行callback中的逻辑。否则通过实现Callback接口回调，或者执行handleMessage，handleMessage也就是我们子类覆写的方法。可以看到，虽然逻辑部分是我们在Handler中实现的，但是调用的地方却是Looper的线程。因为一个Looper绑定一个线程，我们也可以通过比较Looper来比较线程。 ##总结通过分析源码，可以知道android中可以通过Looper为每一个线程创建一个消息队里，UI线程的Looper在Activity启动前就已经初始化。那么对于我们自定义的线程，很明显也可以绑定Looper。自定义线程绑定Looper，最明显的好处就是可以实现线程间通信了，同时由于借助了消息队列，也将并行转为串行实现了线程安全。看一个简单的例子： 12345678910111213new Thread(new Runnable() &#123; @Override public void run() &#123; Looper.prepare(); handlerA = new Handler(Looper.myLooper())&#123; @Override public void handleMessage(Message msg) &#123; Log.d(\"TAG\", msg.obj.toString()); &#125; &#125;; Looper.loop(); &#125;&#125;).start(); 上述在线程中创建绑定了一个Looper，然后新建一个和当前Looper绑定的Handler，这样可以通过该Handler向Looper的MessageQueue中添加消息，然后由Looper.loop取出消息并执行。 123Message msg = new Message();msg.obj = \"i am main thread\";handlerA.sendMessage(msg); 在主线程或者其它线程中获取handler然后发送消息，最终可以看到消息被线程接收并处理。这里msg的target也就是handlerA。注意如果线程工作结束，需要调用Looper.quit()，不然会因为Looper一直循环而导致线程无法结束。 最后经过上面的分析，流程图可以画的更为细致：","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Volley源码分析","slug":"Volley源码分析","date":"2016-08-18T02:04:45.000Z","updated":"2017-04-20T02:05:11.000Z","comments":true,"path":"2016/08/18/Volley源码分析/","link":"","permalink":"http://mryy.com/2016/08/18/Volley源码分析/","excerpt":"","text":"Volley基本使用123456789101112131415161718192021222324252627282930313233//声明一个请求队列，请求队列最好全局唯一。 RequestQueue mQueue = Volley.newRequestQueue(context); //请求的错误回调 Response.ErrorListener errorListener = new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError volleyError) &#123; ... &#125; &#125;;//请求的正确回调Response.Listener listener = new Response.Listener() &#123; @Override public void onResponse(Object o) &#123; &#125; &#125;;//封装好的请求 StringRequest stringRequest = new StringRequest(Request.Method.POST, url, listener, errorListener) &#123; @Override protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123; // TODO Auto-generated method stub if (request.isEmpty()) return super.getParams(); else &#123; return request; &#125; &#125; &#125;; //将封装好的请求加入到请求队列中去 mQueue.add(stringRequest); ##整体框架 Volley整体框架如上图所示，是一个典型的生产者消费者模式。主要可以分成三个部分，一个是封装好的Request，包含请求的类型等等，然后将其投入到RequestQueue中，之后有一个用于分发请求的线程Dispatcher，进行网络请求的执行和回调。下面分部分分析：关键类的UML图，主要四个类为：请求Request、响应Response、网络执行工人线程NetWorkExecutor、结果UI线程回调ResponseDelivery Request抽象父类Request，有多个不同种类的Request。StringRequest的构造器调用父类构造器，在Request中存储http请求的方式，Url和失败回调的地址。成功的回调是一个泛型接口 1234public interface Listener&lt;T&gt; &#123; /** Called when a response is received. */ public void onResponse(T response);&#125; 这里我们将类型参数赋值为String，然后将接口实现并存储在StringRequest中的mListener中。在Request中另有抽象方法parseNetworkResponse和deliverResponse，子类实现，后面消费者消费Request时候，调用parseNetworkResponse解析原始的响应，然后调用deliverResponse分发给UI线程。StringRequest的具体实现： 12345678910@Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); &#125; catch (UnsupportedEncodingException e) &#123; parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); &#125; 将网络响应的报文体直接按字符串转换，封装进Response返回。 123456@Overrideprotected void deliverResponse(String response) &#123; if (mListener != null) &#123; mListener.onResponse(response); &#125;&#125; 然后将Respone通过设置的回调接口，调用来处理客户端想要处理的逻辑。这种典型的写法启示我们，在实现异步逻辑的时候，可以将客户端想要的逻辑利用接口实现，然后封装进一个实体中，当线程完成工作后调用这个实体存储的接口实现，从而客户端可以异步实现逻辑。 ###RequestQueue大致了解了封装的实体类Request后，来看一下生产者和消费者连接的部分RequestQueue。调用Volley类中静态方法newRequestQueue来实例化一个RequestQueue 1234567public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) &#123; mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery;&#125; 构造器中，cache是缓存文件目录，network中封装了如何将Request转化为http请求的方法performRequest，类似于策略模式。Dispatchers就是从队列中拿出Request进行网络请求的workerThread消费者，delivery默认值是new ExecutorDelivery(new Handler(Looper.getMainLooper()))，其中的handler和UI线程的Looper相连，从而可以通过handler向UI线程的消息队列发送消息更改UI，delivery也就是结果处理后的界面更改回调。综上，RequestQueue中封装了Request转换为网络请求的方法，分发请求的工作线程，将结果发送给UI的传递者。调用requestQueue.start()后，启动缓存线程和网络请求线程，主要分析网络请求部分： 123456for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start();&#125; mDispachers是一个数组，类似线程池存储着工人线程。NetworkDispatcher是worker thread， 1234public void quit() &#123; mQuit = true; interrupt();&#125; quit方法通过interrupt和标志位中断一个线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Override public void run() &#123; //设置当前线程为后台线程，减少对于UI线程渲染的影响 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Request&lt;?&gt; request; while (true) &#123; long startTimeMs = SystemClock.elapsedRealtime(); // release previous request object to avoid leaking request object when mQueue is drained. request = null; try &#123; // Take a request from the queue. request = mQueue.take(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. //检查标志位，看队列是否结束 if (mQuit) &#123; return; &#125; continue; &#125; try &#123; // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; request.finish(&quot;network-discard-cancelled&quot;); continue; &#125; // 这里调用网络请求策略network，将Request转化为网络请求处理。获得响应封装。 NetworkResponse networkResponse = mNetwork.performRequest(request); //304缓存处理。没有修改，不进行http请求维持原状。 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(&quot;not-modified&quot;); continue; &#125; // 将原始的网络请求解析，这里是按照StringRequest的方式解析。 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); //缓存相关 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(&quot;network-cache-written&quot;); &#125; // delivery，分发更改UI request.markDelivered(); mDelivery.postResponse(request, response); &#125; catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); &#125; &#125; &#125; ###Delivery分发部分的实现 12345public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(&quot;post-response&quot;); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));&#125; 其中 123456mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125;&#125;; ResponseDeliveryRunnable是给UI线程的Handler发送的Runnable，也就是说这部分是执行在UI线程上的，其中逻辑部分： 1234567891011121314151617181920212223242526272829@SuppressWarnings(&quot;unchecked&quot;) @Override public void run() &#123; // If this request has canceled, finish it and don&apos;t deliver. if (mRequest.isCanceled()) &#123; mRequest.finish(&quot;canceled-at-delivery&quot;); return; &#125; // 调用我们定义的Request中的listener回调 if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we&apos;re done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker(&quot;intermediate-response&quot;); &#125; else &#123; mRequest.finish(&quot;done&quot;); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); &#125; &#125; 可以看在，最初在Request中封装的更改UI的listener，在mRequest.deliverResponse(mResponse.result); 被异步调用并执行，并且通过ExecutorDelivery确保在UI线程中执行，ExecutorDelivery类似命令模式，dispatcher负责网络部分，Delivery负责UI部分，确保收到的每个Request响应的回调执行在UI线程中。 ##总结作为生产者-消费者模式，客户端可以将网络请求的处理方式，获取响应后的处理逻辑封装进Request，然后放进RequestQueue中。对于一个全局的RequestQueue，维护一个工作线程池，利用多个线程从队列中去除Request去执行网络请求，根据Request中封装的网络请求方法获取Response后，将结果给Delivery。然后通过Delivery分发给UI线程，调用Request中更新的UI处理逻辑。对比传统的通过新建线程实现网络请求的方式，volley采用的方式不仅逻辑清晰、易于管理，同时将线程维护、UI更新这部分不易发生变化的工作封装，用户也可通过继承Request实现扩展，增强了可维护性。","raw":null,"content":null,"categories":[],"tags":[]}]}