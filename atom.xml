<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang Yang的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mryy.com/"/>
  <updated>2017-04-19T12:41:57.000Z</updated>
  <id>http://mryy.com/</id>
  
  <author>
    <name>Yang Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus 源码分析</title>
    <link href="http://mryy.com/2017/04/19/EventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mryy.com/2017/04/19/EventBus-源码分析/</id>
    <published>2017-04-19T11:15:03.000Z</published>
    <updated>2017-04-19T12:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>EventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。</p>
<h2 id="register-发布过程"><a href="#register-发布过程" class="headerlink" title="register  发布过程"></a>register  发布过程</h2><p>register 主要包括两个过程：</p>
<ul>
<li>找到当前注册的对象中onEvent相关订阅方法</li>
<li>订阅者对找出的方法进行订阅。</li>
</ul>
<h3 id="findSubscriberMethods"><a href="#findSubscriberMethods" class="headerlink" title="findSubscriberMethods"></a>findSubscriberMethods</h3><p>利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (modifierString.length() == 0) &#123;</div><div class="line">                        threadMode = ThreadMode.PostThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.MainThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.BackgroundThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.Async;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (skipMethodVerificationForClasses.containsKey(clazz)) &#123;</div><div class="line">                            continue;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。<br>找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。</p>
<h3 id="subscribe-订阅过程"><a href="#subscribe-订阅过程" class="headerlink" title="subscribe 订阅过程"></a>subscribe 订阅过程</h3><p>第一阶段找到所有方法后，第二阶段先执行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">    subscribe(subscriber, subscriberMethod, sticky, priority);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>subscribe方法主要包含以下过程：</p>
<ul>
<li>根据EventType找到订阅该事件的订阅队列</li>
<li>找到subsciber订阅的全部事件，并将当前事件添加进去。</li>
<li>处理stick类型的event。</li>
</ul>
<h4 id="subscriptionsByEventType"><a href="#subscriptionsByEventType" class="headerlink" title="subscriptionsByEventType"></a>subscriptionsByEventType</h4><p>EventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);</div><div class="line">        if (subscriptions == null) &#123;</div><div class="line">            subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面的代码就获得了某个event对应的订阅队列。<br>然后根据优先级将subscription插入合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">    if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</div><div class="line">        subscriptions.add(i, newSubscription);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="typesBySubscriber"><a href="#typesBySubscriber" class="headerlink" title="typesBySubscriber"></a>typesBySubscriber</h4><p>同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">if (subscribedEvents == null) &#123;</div><div class="line">    subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">    typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">&#125;</div><div class="line">subscribedEvents.add(eventType);</div></pre></td></tr></table></figure>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p>第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized (stickyEvents) &#123;</div><div class="line">    stickyEvent = stickyEvents.get(eventType);</div><div class="line">&#125;</div><div class="line">if (stickyEvent != null) &#123;</div><div class="line">     postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="post过程"><a href="#post过程" class="headerlink" title="post过程"></a>post过程</h2><h3 id="currentPostingThreadState"><a href="#currentPostingThreadState" class="headerlink" title="currentPostingThreadState"></a>currentPostingThreadState</h3><p>虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    protected PostingThreadState initialValue() &#123;</div><div class="line">        return new PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (!eventQueue.isEmpty()) &#123;</div><div class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<h3 id="postSingleEvent"><a href="#postSingleEvent" class="headerlink" title="postSingleEvent"></a>postSingleEvent</h3><p>流程：</p>
<ul>
<li>将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。</li>
<li>寻找该事件的订阅者，并将事件交给订阅的subscription进行处理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">synchronized (this) &#123;</div><div class="line">                subscriptions = subscriptionsByEventType.get(clazz);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">for (Subscription subscription : subscriptions) &#123;</div><div class="line">    postingState.event = event;</div><div class="line">    postingState.subscription = subscription;</div><div class="line">    boolean aborted = false;</div><div class="line">    try &#123;</div><div class="line">        postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">        aborted = postingState.canceled;</div><div class="line">    &#125; finally &#123;</div><div class="line">        postingState.event = null;</div><div class="line">        postingState.subscription = null;</div><div class="line">        postingState.canceled = false;</div><div class="line">    &#125;</div><div class="line">    if (aborted) &#123;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。</p>
<ul>
<li><p>第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!subscriptionFound) &#123;</div><div class="line">    Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);</div><div class="line">    if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">        post(new NoSubscriberEvent(this, event));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>
<h3 id="postToSubscription"><a href="#postToSubscription" class="headerlink" title="postToSubscription"></a>postToSubscription</h3><p>EventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</div><div class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">    case PostThread:</div><div class="line">        invokeSubscriber(subscription, event);</div><div class="line">        break;</div><div class="line">    case MainThread:</div><div class="line">        if (isMainThread) &#123;</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">        &#125; else &#123;</div><div class="line">            mainThreadPoster.enqueue(subscription, event);</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    case BackgroundThread:</div><div class="line">        if (isMainThread) &#123;</div><div class="line">            backgroundPoster.enqueue(subscription, event);</div><div class="line">        &#125; else &#123;</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    case Async:</div><div class="line">        asyncPoster.enqueue(subscription, event);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况：</p>
<ul>
<li>直接invokeSubscriber</li>
<li>将subscription和event给到指定的Poster中</li>
</ul>
<h4 id="invokeSubscriber"><a href="#invokeSubscriber" class="headerlink" title="invokeSubscriber"></a>invokeSubscriber</h4><p>方法中首先直接反射调用注册该事件的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div></pre></td></tr></table></figure>
<p>从发布到订阅，就这么简单粗暴的完成了。</p>
<h4 id="Poster"><a href="#Poster" class="headerlink" title="Poster"></a>Poster</h4><p>EventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。</p>
<ul>
<li><p>HandlerPoster</p>
<p>如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">synchronized (this) &#123;</div><div class="line">    queue.enqueue(pendingPost);</div><div class="line">    if (!handlerActive) &#123;</div><div class="line">        handlerActive = true;</div><div class="line">        if (!sendMessage(obtainMessage())) &#123;</div><div class="line">            throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">while (true) &#123;</div><div class="line">    PendingPost pendingPost = queue.poll();</div><div class="line">    if (pendingPost == null) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Check again, this time in synchronized</div><div class="line">            pendingPost = queue.poll();</div><div class="line">            if (pendingPost == null) &#123;</div><div class="line">                handlerActive = false;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eventBus.invokeSubscriber(pendingPost);</div><div class="line">    long timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">    if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">        if (!sendMessage(obtainMessage())) &#123;</div><div class="line">            throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">        &#125;</div><div class="line">        rescheduled = true;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleMessage中流程：</p>
<ul>
<li>从pendingPostQueue中取出待处理的post，调用相应subscription执行</li>
<li>防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。</li>
</ul>
<p>总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。</p>
<h4 id="BackgroundPoster"><a href="#BackgroundPoster" class="headerlink" title="BackgroundPoster"></a>BackgroundPoster</h4><p>HandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。</p>
<p>runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">while (true) &#123;</div><div class="line">    PendingPost pendingPost = queue.poll(1000);</div><div class="line">    if (pendingPost == null) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Check again, this time in synchronized</div><div class="line">            pendingPost = queue.poll();</div><div class="line">            if (pendingPost == null) &#123;</div><div class="line">                executorRunning = false;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eventBus.invokeSubscriber(pendingPost);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，EventBus的发布订阅模型分析完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EventBus&quot;&gt;&lt;a href=&quot;#EventBus&quot; class=&quot;headerlink&quot; title=&quot;EventBus&quot;&gt;&lt;/a&gt;EventBus&lt;/h2&gt;&lt;p&gt;EventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RecyclerView 源码学习及自定义LayoutManager</title>
    <link href="http://mryy.com/2017/03/13/RecyclerView-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/"/>
    <id>http://mryy.com/2017/03/13/RecyclerView-源码学习及自定义LayoutManager/</id>
    <published>2017-03-13T15:49:31.000Z</published>
    <updated>2017-04-19T13:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RecyclerView-的三驾马车"><a href="#RecyclerView-的三驾马车" class="headerlink" title="RecyclerView 的三驾马车"></a>RecyclerView 的三驾马车</h1><h2 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h2><p>掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。</p>
<h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>layout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。</p>
<p>在RecyclerView 进行 onMeasure的时候，调用了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (mLayout == null) &#123;</div><div class="line">    defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">&#125; else &#123;</div><div class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为</p>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>LayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。</p>
<h3 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h3><p>adapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。</p>
<p>ViewHolder构造代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public ViewHolder(View itemView) &#123;</div><div class="line">    if (itemView == null) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;itemView may not be null&quot;);</div><div class="line">    &#125;</div><div class="line">    this.itemView = itemView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    public final VH createViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);</div><div class="line">        final VH holder = onCreateViewHolder(parent, viewType);</div><div class="line">        holder.mItemViewType = viewType;</div><div class="line">        TraceCompat.endSection();</div><div class="line">        return holder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。</p>
<h4 id="ViewHolder中的ItemView"><a href="#ViewHolder中的ItemView" class="headerlink" title="ViewHolder中的ItemView"></a>ViewHolder中的ItemView</h4><h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h2><p>ItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。</p>
<p>在说明ItemDecoration之前首先要看一下view中draw事件的传递：</p>
<p>View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程：</p>
<ol>
<li>绘制背景 drawBackground</li>
<li>绘制视图内容，即调用自身的 onDraw</li>
<li>绘制child view</li>
</ol>
<p>使用ItemDecoration，主要通过覆写以下方法：</p>
<h3 id="getItemOffsets"><a href="#getItemOffsets" class="headerlink" title="getItemOffsets"></a>getItemOffsets</h3><p>可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码：</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>RecyclerView 被父布局调用draw方法，draw方法中关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas c) &#123;</div><div class="line">    super.draw(c);</div><div class="line">    final int count = mItemDecorations.size();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mItemDecorations.get(i).onDrawOver(c, this, mState);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void onDraw(Canvas c) &#123;</div><div class="line">    super.onDraw(c);</div><div class="line">    final int count = mItemDecorations.size();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mItemDecorations.get(i).onDraw(c, this, mState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">View next(RecyclerView.Recycler recycler) &#123;</div><div class="line">    if (mScrapList != null) &#123;</div><div class="line">        return nextViewFromScrapList();</div><div class="line">    &#125;</div><div class="line">    final View view = recycler.getViewForPosition(mCurrentPosition);</div><div class="line">    mCurrentPosition += mItemDirection;</div><div class="line">    return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#### </p>
<p>measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘，</p>
<hr>
<p>上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h2><p>LayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。</p>
<h2 id="Scrap-或-Recycler"><a href="#Scrap-或-Recycler" class="headerlink" title="Scrap 或 Recycler"></a>Scrap 或 Recycler</h2><p>Recycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。</p>
<p>每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。</p>
<p>使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView</p>
<h1 id="自定义LayoutManager"><a href="#自定义LayoutManager" class="headerlink" title="自定义LayoutManager"></a>自定义LayoutManager</h1><h3 id="generateDefaultLayoutParams"><a href="#generateDefaultLayoutParams" class="headerlink" title="generateDefaultLayoutParams"></a>generateDefaultLayoutParams</h3><p>作用：控制每个item的layoutParams<br>为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp</p>
<h3 id="初始布局-onLayoutChildren"><a href="#初始布局-onLayoutChildren" class="headerlink" title="初始布局 onLayoutChildren"></a>初始布局 onLayoutChildren</h3><p>这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (getItemCount() == 0) &#123;</div><div class="line">    offset = 0;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (getChildCount() == 0) &#123;</div><div class="line">    View scrap = recycler.getViewForPosition(0);</div><div class="line">    addView(scrap);</div><div class="line">    measureChildWithMargins(scrap, 0, 0);</div><div class="line">    mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);</div><div class="line">    mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);</div><div class="line">    startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2;</div><div class="line">    startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2;</div><div class="line">    interval = 10;</div><div class="line">    detachAndScrapView(scrap, recycler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">recycler.getViewForPosition(0);</div><div class="line">            addView(scrap);</div></pre></td></tr></table></figure>
<p>测绘完成后，再重新放回recycler中，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detachAndScrapView(scrap, recycler);</div></pre></td></tr></table></figure>
<p>最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detachAndScrapAttachedViews(recycler);</div></pre></td></tr></table></figure>
<p>然后就可以进行layoutChildren的过程了。</p>
<p>先来一个简单的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int left = 100, top = 0;</div><div class="line">        for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">            if (outOfRange(top)) continue;</div><div class="line">            View scrap = recycler.getViewForPosition(i);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            addView(scrap);</div><div class="line">            layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight);</div><div class="line">            top += mDecoratedChildHeight + interval;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>基本效果就是这样：<br><img src="http://img.blog.csdn.net/20170313154744954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="处理滑动-canScroll-和-scrollXXXBy"><a href="#处理滑动-canScroll-和-scrollXXXBy" class="headerlink" title="处理滑动 canScroll 和 scrollXXXBy"></a>处理滑动 canScroll 和 scrollXXXBy</h3><p>基本的布局有了之后，就可以处理滑动了。<br>RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法：</p>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line"> final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"> ...</div><div class="line"> case MotionEvent.ACTION_MOVE:</div><div class="line"> ...</div><div class="line"> if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                 mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1);</div><div class="line">                 startScroll = true;</div><div class="line">             &#125;</div><div class="line">if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                 mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1);</div><div class="line">                 startScroll = true;</div><div class="line">             &#125;</div><div class="line">             ...</div><div class="line">if (startScroll) &#123;                      setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">             &#125;</div><div class="line">             ...</div><div class="line">return mScrollState == SCROLL_STATE_DRAGGING;</div></pre></td></tr></table></figure>
<p>这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。<br>比如我们要允许竖直方向的滑动，直接重写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean canScrollVertically() &#123;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下事件拦截以后，在onTouchEvent中怎么处理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (scrollByInternal(</div><div class="line">                    canScrollHorizontally ? dx : 0,</div><div class="line">                        canScrollVertically ? dy : 0,</div><div class="line">                            vtev)) &#123;</div><div class="line">getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">                    &#125;</div></pre></td></tr></table></figure>
<p>代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (x != 0) &#123;</div><div class="line">    consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</div><div class="line">    unconsumedX = x - consumedX;</div><div class="line">&#125;</div><div class="line">if (y != 0) &#123;</div><div class="line">    consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</div><div class="line">    unconsumedY = y - consumedY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。</p>
<p>除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">     return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>返回0的时候，无论怎样都会小于传入的dy，看一下效果：</p>
<p><img src="http://img.blog.csdn.net/20170313161058596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。</p>
<p>分析到这里，基本可以确定如何添加滚动效果了，关键在两点：</p>
<ol>
<li>canScrollXXX中返回true</li>
<li>在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。</li>
</ol>
<p>为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。</p>
<p>首先，用一个全局变量 List<float> offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化：</float></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; getItemCount(); i++) &#123;</div><div class="line">    offsetList.add(property);</div><div class="line">    property += mDecoratedChildHeight + interval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>滑动方面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">    int willScroll = dy;</div><div class="line">    offset += willScroll;</div><div class="line">    layoutItems(recycler, state, dy);</div><div class="line">    return willScroll;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且，原先对item的layout的过程也要进行一些修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">    for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View view = getChildAt(i);</div><div class="line">        int pos = getPosition(view);</div><div class="line">        if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">            removeAndRecycleView(view, recycler);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    int left = 100;</div><div class="line">    for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">        int top = offsetList.get(i);</div><div class="line">        if (outOfRange(top - offset)) continue;</div><div class="line">        View scrap = recycler.getViewForPosition(i);</div><div class="line">        measureChildWithMargins(scrap, 0, 0);</div><div class="line">        if (dy &gt;= 0)</div><div class="line">            addView(scrap);</div><div class="line">        else</div><div class="line">            addView(scrap, 0);</div><div class="line">        layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170313171417783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。<br>到此为止，就有了滑动的动画效果：</p>
<p><img src="http://img.blog.csdn.net/20170313172759587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="缩放效果"><a href="#缩放效果" class="headerlink" title="缩放效果"></a>缩放效果</h3><p>经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。</p>
<p>实现的思路也比较简单，定一条基准线middle如下：</p>
<p><img src="http://img.blog.csdn.net/20170313175823822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。</p>
<p>新的layoutItems代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">    for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View view = getChildAt(i);</div><div class="line">        int pos = getPosition(view);</div><div class="line">        if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">            removeAndRecycleView(view, recycler);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    int left = 100;</div><div class="line">    View selectedView = null;</div><div class="line">    float maxScale = Float.MIN_VALUE;</div><div class="line">    for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">        int top = offsetList.get(i);</div><div class="line">        if (outOfRange(top - offset)) continue;</div><div class="line">        View scrap = recycler.getViewForPosition(i);</div><div class="line">        measureChildWithMargins(scrap, 0, 0);</div><div class="line">        if (dy &gt;= 0)</div><div class="line">            addView(scrap);</div><div class="line">        else</div><div class="line">            addView(scrap, 0);</div><div class="line"></div><div class="line">        int deltaY = Math.abs(top - offset - middle);</div><div class="line">        scrap.setScaleX(1);</div><div class="line">        scrap.setScaleY(1);</div><div class="line">        float scale = 1 + (mDecoratedChildHeight / (deltaY + 1));</div><div class="line">        if (scale &gt; maxScale) &#123;</div><div class="line">            maxScale = scale;</div><div class="line">            selectedView = scrap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (selectedView != null) &#123;</div><div class="line">        maxScale = maxScale &gt; 2 ? 2 : maxScale;</div><div class="line">        selectedView.setScaleX(maxScale);</div><div class="line">        selectedView.setScaleY(maxScale);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后可以得到下面这样一个比较粗糙的效果：</p>
<p><img src="http://img.blog.csdn.net/20170313180136946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最后，来贴一下完整的代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">package rouchuan.circlelayoutmanager;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.support.v7.widget.RecyclerView;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by yangyang on 2017/3/13.</div><div class="line"> */</div><div class="line"></div><div class="line">public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123;</div><div class="line">    private int mDecoratedChildWidth;</div><div class="line">    private int mDecoratedChildHeight;</div><div class="line">    private int interval;</div><div class="line">    private int middle;</div><div class="line">    private int offset;</div><div class="line">    private List&lt;Integer&gt; offsetList;</div><div class="line">    public SimpleLayoutManager(Context context) &#123;</div><div class="line">        offsetList = new ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        if (getItemCount() == 0) &#123;</div><div class="line">            offset = 0;</div><div class="line">            detachAndScrapAttachedViews(recycler);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的</div><div class="line">        if (getChildCount() == 0) &#123;</div><div class="line">            View scrap = recycler.getViewForPosition(0);</div><div class="line">            addView(scrap);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);</div><div class="line">            mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);</div><div class="line">            interval = 10;</div><div class="line">            middle = (getVerticalSpace() - mDecoratedChildHeight) / 2;</div><div class="line">            detachAndScrapView(scrap, recycler);</div><div class="line">        &#125;</div><div class="line">        //回收全部attach 的 view 到 recycler 并重新排列</div><div class="line">        int property = 0;</div><div class="line">        for (int i = 0; i &lt; getItemCount(); i++) &#123;</div><div class="line">            offsetList.add(property);</div><div class="line">            property += mDecoratedChildHeight + interval;</div><div class="line">        &#125;</div><div class="line">        detachAndScrapAttachedViews(recycler);</div><div class="line">        layoutItems(recycler, state, 0);</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean canScrollVertically() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        int willScroll = dy;</div><div class="line">        offset += willScroll;</div><div class="line">        if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0;</div><div class="line">        layoutItems(recycler, state, dy);</div><div class="line">        return willScroll;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">        for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">            View view = getChildAt(i);</div><div class="line">            int pos = getPosition(view);</div><div class="line">            if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">                removeAndRecycleView(view, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        detachAndScrapAttachedViews(recycler);</div><div class="line">        int left = 100;</div><div class="line">        View selectedView = null;</div><div class="line">        float maxScale = Float.MIN_VALUE;</div><div class="line">        for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">            int top = offsetList.get(i);</div><div class="line">            if (outOfRange(top - offset)) continue;</div><div class="line">            View scrap = recycler.getViewForPosition(i);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            if (dy &gt;= 0)</div><div class="line">                addView(scrap);</div><div class="line">            else</div><div class="line">                addView(scrap, 0);</div><div class="line"></div><div class="line">            int deltaY = Math.abs(top - offset - middle);</div><div class="line">            scrap.setScaleX(1);</div><div class="line">            scrap.setScaleY(1);</div><div class="line">            float scale = 1 + (mDecoratedChildHeight / (deltaY + 1));</div><div class="line">            if (scale &gt; maxScale) &#123;</div><div class="line">                maxScale = scale;</div><div class="line">                selectedView = scrap;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (selectedView != null) &#123;</div><div class="line">            maxScale = maxScale &gt; 2 ? 2 : maxScale;</div><div class="line">            selectedView.setScaleX(maxScale);</div><div class="line">            selectedView.setScaleY(maxScale);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private boolean outOfRange(float targetOffSet) &#123;</div><div class="line">        return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight ||</div><div class="line">                targetOffSet &lt; -mDecoratedChildHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getHorizontalSpace() &#123;</div><div class="line">        return getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getVerticalSpace() &#123;</div><div class="line">        return getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RecyclerView-的三驾马车&quot;&gt;&lt;a href=&quot;#RecyclerView-的三驾马车&quot; class=&quot;headerlink&quot; title=&quot;RecyclerView 的三驾马车&quot;&gt;&lt;/a&gt;RecyclerView 的三驾马车&lt;/h1&gt;&lt;h2 id=&quot;L
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收知识总结</title>
    <link href="http://mryy.com/2017/01/19/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://mryy.com/2017/01/19/JVM垃圾回收知识总结/</id>
    <published>2017-01-19T02:01:42.000Z</published>
    <updated>2017-04-20T02:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>##前言<br>java文件被jvm编译成.class文件，.class文件中全部是二进制的数据。在JVM中用一个8bit的变量类型存储指令，这样0到255可以表示总共256个指令。我们编写的代码被编译成相应的指令码交给计算机执行，而在对代码进行调优的时候，可以读懂编译后的.class文件也是很重要的。</p>
<p>##基础知识</p>
<p>###Java内存模型<br><img src="http://img.blog.csdn.net/20170119193553642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>首先要先了解一下Java的内存模型，我们比较关心的主要有四个部分：堆，虚拟机栈，本地方法栈，方法区。<br>堆一般存放对象实例，也就是我们new 分配的对象，堆中依据对象存活时间分为新生代和老年代，新生代中又分为Eden空间和Survivor空间（主要是执行复制回收算法时使用的空间），新生代的Survivor空间又分成from空间和to空间。这里简单介绍一下新生代中发生垃圾回收的过程：<br><img src="http://img.blog.csdn.net/20170124112234731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>新生代生成对象的时候，首先分配在Eden区，当Eden区满了以后，执行复制清除算法，将Eden区的对象复制到From然后清除Edne区。这样下一轮时，可以继续在Eden区中分配，Eden和From区是目前存活的对象，当Eden再次满了以后，下一次MinorGC（针对新生代的GC，MajorGC针对老年代，FullGC针对全部）会将Eden和From复制到To中并清除原来的内容，以此类推。如果存活的对象太多导致Survivor区域无法容纳，还需要老年代进行分配担保，将无法保存在Survivor中的对象直接晋升到老年代。<br>方法区主要存放一些静态变量，类信息等，通常我们可以把这部分看作永久代，因为其中分配的对象不会被垃圾收集。<br>运行时常量池是class文件中每一个类或者接口的常量表，包含了字面量和符号饮用，充当一个符号表的作用。比如Java中的字符串，默认声明其实作为字面量存储在常量池中的，参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String a = &quot;abc&quot;;</div><div class="line">      String b = &quot;abc&quot;;</div><div class="line">      String c = new String(&quot;abc&quot;);</div><div class="line">      System.out.println(a == b);</div><div class="line">      System.out.println(a == c);</div></pre></td></tr></table></figure>
<p>代码中，a==b返回true，a==c返回false，这是因为默认a和b的声明方式实际是在常量池中声明一个符号，然后a和b都指向那个符号”abc”，而c是在堆中声明了一个char数组。java中==默认判断的是两个值地址是否相等，所以第一个返回true，第二个返回false。<br>前面提到，常量池相当于一个符号表。我们可以把它看作一个表结构，键是常量地址，值就是存储的值。如下：<br><img src="http://img.blog.csdn.net/20170119194745288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>而符号引用，其实就是指类和接口的全限定名和方法的描述符，熟悉jni的话会比较清楚这些东西。简单来讲，在一个实例中可能有另一个对象的引用，那么在class文件中其实存放的是符号引用，也就是java/lang/object 这种字符串，而不是真正的指向内存地址的引用。在动态链接的过程，才会把class文件中这些“假的”符号饮用转换成真正的直接引用（也就是指向一个内存地址）。<br>本地方法栈就是通过Jni调用底层方法的时候，本地C/C++代码执行时候的方法栈。<br>虚拟机栈就是我们的Java代码执行的栈了，也是本文的重点。<br>￼</p>
<p>###Java虚拟机栈</p>
<p>####栈帧<br>当一个方法被调用的时候，就进入它所在的方法栈，栈帧随着方法的创建而创建，随着方法的结束而销毁。每一个栈帧都拥有自己的本地变量表，操作数栈和运行时常量池的引用。</p>
<p>####局部变量表<br>局部变量表中用slot来进行存储，一个slot可以存放一个boolean、byte、char、short、int、float、reference或returnAddress的数据，两个slot可以存储一个long或double。</p>
<p>####操作数栈<br>每个栈帧中有一个操作数栈，用来存放指令执行的中间结果。有点类似于一个栈实现的计算器。<br>比如当我们执行一个iadd指令中，则要求操作数栈顶是两个int类型的数值，执行iadd后会把两个数值取出来求和再把结果放回操作数栈中。</p>
<p>###基本指令集<br>.class文件是二进制文件，严格规定了每个字节的含义。是一组以8位字节为基础单位的二进制流，所以又叫字节码。只有两种数据类型：无符号数和表。<br>无符号数可以存放数字、索引引用或者UTF－8编码构成的字符串值。<br>表是无符号数和其他表构成的符合数据类型。指令码由一个字节表示，不同的数字0到200多代表不同的指令。<br>当然在分析的时候，我们一般使用javap -verbose 命令对class文件进行反编译，可以得到相应的明文指令，避免了我们对字节码参照JVM规范手册人工去翻译。所以我们主要关注的是一些指令的具体含义。</p>
<p>####加载和存储指令</p>
<ul>
<li>将一个本地变量加载到操作数栈：load相关指令，比如iload加载int类型，fload加载float类型等</li>
<li>将数值从操作数栈加载到本地变量表：store相关指令</li>
<li>加载常量到操作数栈：push、const相关指令<br>对于一些指令，比如iload_1,iload_2就是将操作数隐藏在指令中，就等同于iload 1，iload 2.<br>此外，需要说明，iconst n是把常量n压入操作数栈，istore n 是把操作数栈顶的数存在本地变量表第n个位置，iload n是把本地变量表第n个元素压入操作数栈，本地变量表可以看作一个ArrayList链表数据结构。<br><img src="http://img.blog.csdn.net/20170119234727453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li>
</ul>
<p>可以看到在栈帧中，对于变量的操作流程，基本就是把值从常量池拿到操作数栈，要存储的话就放在本地变量表，要计算了再拿到操作数栈，然后调用相应的指令进行计算。</p>
<p>####算数指令<br>算数指令用于两个操作数栈上的值进行特定运算，并把计算结果压入操作数栈。比如add，sub，mul，div相关。</p>
<p>####方法调用和返回指令<br>invokevirtual用于调用实例方法，invokespecial用于调用一些特殊实例方法，比如构造方法，invokestatic用于调用静态方法。<br>返回指令即return相关，比如ireturn。</p>
<p>####其余指令<br>其余指令包括类型转换指令，对象创建与操作指令，操作数栈管理指令和控制转移指令，在这里不详细介绍可以查阅Java虚拟机规范。</p>
<p>##实例<br>下面介绍一个工程实例，Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> a + b;</div><div class="line">    &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用javap -verbose命令对class文件进行反编译，查看字节码：<br>反编译后，生成的字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">public class Main</div><div class="line">  minor version: 0</div><div class="line">  major version: 52</div><div class="line">  flags: ACC_PUBLIC, ACC_SUPER</div><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">   #2 = Class              #25            // java/util/Random</div><div class="line">   #3 = Methodref          #2.#24         // java/util/Random.&quot;&lt;init&gt;&quot;:()V</div><div class="line">   #4 = Methodref          #2.#26         // java/util/Random.nextInt:(I)I</div><div class="line">   #5 = Class              #27            // Main</div><div class="line">   #6 = Class              #28            // java/lang/Object</div><div class="line">   #7 = Utf8               &lt;init&gt;</div><div class="line">   #8 = Utf8               ()V</div><div class="line">   #9 = Utf8               Code</div><div class="line">  #10 = Utf8               LineNumberTable</div><div class="line">  #11 = Utf8               LocalVariableTable</div><div class="line">  #12 = Utf8               this</div><div class="line">  #13 = Utf8               LMain;</div><div class="line">  #14 = Utf8               cal</div><div class="line">  #15 = Utf8               ()I</div><div class="line">  #16 = Utf8               a</div><div class="line">  #17 = Utf8               I</div><div class="line">  #18 = Utf8               b</div><div class="line">  #19 = Utf8               getInteger</div><div class="line">  #20 = Utf8               random</div><div class="line">  #21 = Utf8               Ljava/util/Random;</div><div class="line">  #22 = Utf8               SourceFile</div><div class="line">  #23 = Utf8               Main.java</div><div class="line">  #24 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</div><div class="line">  #25 = Utf8               java/util/Random</div><div class="line">  #26 = NameAndType        #29:#30        // nextInt:(I)I</div><div class="line">  #27 = Utf8               Main</div><div class="line">  #28 = Utf8               java/lang/Object</div><div class="line">  #29 = Utf8               nextInt</div><div class="line">  #30 = Utf8               (I)I</div><div class="line">&#123;</div><div class="line">  public Main();</div><div class="line">    descriptor: ()V</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=1, locals=1, args_size=1</div><div class="line">         0: aload_0</div><div class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">         4: return</div><div class="line">      LineNumberTable:</div><div class="line">        line 3: 0</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">            0       5     0  this   LMain;</div><div class="line"></div><div class="line">  public int cal();</div><div class="line">    descriptor: ()I</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=3, args_size=1</div><div class="line">         0: iconst_1</div><div class="line">         1: istore_1</div><div class="line">         2: iconst_1</div><div class="line">         3: istore_2</div><div class="line">         4: iload_1</div><div class="line">         5: iload_2</div><div class="line">         6: iadd</div><div class="line">         7: ireturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 6: 0</div><div class="line">        line 7: 2</div><div class="line">        line 8: 4</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">            0       8     0  this   LMain;</div><div class="line">            2       6     1     a   I</div><div class="line">            4       4     2     b   I</div><div class="line"></div><div class="line">  public int getInteger();</div><div class="line">    descriptor: ()I</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=2, args_size=1</div><div class="line">         0: new           #2                  // class java/util/Random</div><div class="line">         3: dup</div><div class="line">         4: invokespecial #3                  // Method java/util/Random.&quot;&lt;init&gt;&quot;:()V</div><div class="line">         7: astore_1</div><div class="line">         8: aload_1</div><div class="line">         9: iconst_5</div><div class="line">        10: invokevirtual #4                  // Method java/util/Random.nextInt:(I)I</div><div class="line">        13: ireturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 12: 0</div><div class="line">        line 13: 8</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">            0      14     0  this   LMain;</div><div class="line">            8       6     1 random   Ljava/util/Random;</div><div class="line">&#125;</div><div class="line">SourceFile: &quot;Main.java&quot;</div></pre></td></tr></table></figure>
<p>下面开始分析主要部分：</p>
<p>###运行时常量池<br>Constant pool 就是前面提到的运行时常量池，类似一个符号表，前面表示在常量池中的地址，后面的字段就是相应的值，同时Javap还会帮助我们生成一些字段辅助查看：</p>
<p>   #1 = Methodref          #6.#24         // java/lang/Object.”<init>“:()V</init></p>
<p>   #2 = Class              #25            // java/util/Random</p>
<p>  #25 = Utf8               java/util/Random</p>
<p>  #26 = NameAndType        #29:#30        // nextInt:(I)I</p>
<p>在我们class文件的常量池中有四种类型的常量，Utf8就是字面常量，一个字符串。而Methodref是一个方法的符号引用，为什么说是符号引用呢，就是因为最后看到它其实就是一个方法描述符：字符串而已。同时，Class表示引用到的一个类，NameAndType表示一个字段或者方法。</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>下面是方法的描述符标志位等信息，然后是最重要的信息：code属性。<br>分析其中的cal方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public int cal();</div><div class="line">    descriptor: ()I</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=2, locals=3, args_size=1</div><div class="line">	  ...</div><div class="line">      LineNumberTable:</div><div class="line">        line 6: 0</div><div class="line">        line 7: 2</div><div class="line">        line 8: 4</div><div class="line">      LocalVariableTable:</div><div class="line">        Start  Length  Slot  Name   Signature</div><div class="line">            0       8     0  this   LMain;</div><div class="line">            2       6     1     a   I</div><div class="line">            4       4     2     b   I</div></pre></td></tr></table></figure>
<p>stack ＝ 2表明操作数栈最大深度是2，locals＝3是本地变量表最大数目为3，args_size ＝ 1，是因为该方法是实例方法，所以默认有一个输入参数this，指向方法所在的实例。<br>下面的LineNumberTable表示java源代码和字节码的对应关系，用于堆栈跟踪。<br>LocalVariableTable描述局部变量表中的变量和Java源代码定义变量的对应关系。其中start代表局部变量声明开始，length表示在字节码中存活的长度，结合起来就是作用域范围。参考下面的指令码：this在一开始就声明，时间限定为0，变量a在第二个时刻 istore_1存入局部变量表，所以start的值就是2，b在第四个时刻存入，所以start是4，声明周期可以依次推理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0: iconst_1</div><div class="line">1: istore_1</div><div class="line">2: iconst_1</div><div class="line">3: istore_2</div><div class="line">4: iload_1</div><div class="line">5: iload_2</div><div class="line">6: iadd</div><div class="line">7: ireturn</div></pre></td></tr></table></figure>
<p>再来简单分析一下指令，结合前面提高的指令介绍：<br>iconst_1，将常数1加载到操作数栈，istore_1将1从操作数栈栈顶元素1存储到局部变量表第一个位置，下面的2，3条指令同理。iload_1把局部变量表第一个元素加入操作数栈，iload_2同理，现在操作数栈有两个元素 1、1，然后iadd取出栈顶两个元素相加，ireturn返回。</p>
<p>##总结<br>基本内容就是这些，对于字节码的学习，更详细的内容可以参考Java虚拟机规范。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前言&lt;br&gt;java文件被jvm编译成.class文件，.class文件中全部是二进制的数据。在JVM中用一个8bit的变量类型存储指令，这样0到255可以表示总共256个指令。我们编写的代码被编译成相应的指令码交给计算机执行，而在对代码进行调优的时候，可以读懂编译后的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存泄漏分析实战</title>
    <link href="http://mryy.com/2016/12/21/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    <id>http://mryy.com/2016/12/21/Android内存泄漏分析实战/</id>
    <published>2016-12-21T12:52:34.000Z</published>
    <updated>2017-04-19T14:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。<br>本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。<br>撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。</p>
<p>#<strong>内存泄漏基本概念</strong></p>
<p>内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。<br>编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。<br>内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：<br>1、静态变量持有Activity的context。<br>2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。<br>3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。</p>
<hr>
<p>#<strong>内存检测工具</strong></p>
<p>##LeakCananry</p>
<p>###使用步骤</p>
<p>LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。<br>方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。<br><img src="http://img.blog.csdn.net/20161221161742393?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图：<br><img src="http://img.blog.csdn.net/20161221161848567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>###整体流程<br>LeakCananry实现步骤大致是：<br>实现大致步骤是：<br>1、自动把activity加入到KeyedWeakReference<br>2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc<br>3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中<br>4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。<br>5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。<br>6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。<br>7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。</p>
<p>###结论<br><strong>方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。</strong> 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。</p>
<hr>
<p>##观看整体内存使用情况<br>详情参见官方文档：<br><a href="https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations" target="_blank" rel="external">https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations</a><br>使用adb shell，进入手机adb，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dumpsys meminfo &lt;包名&gt; [-参数]</div></pre></td></tr></table></figure>
<p>可以查看应用不同部分内存分配情况。比如Java heap，Native heap等<br>输出是目前具体应用的内存分配，单位是kilobytes<br>因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。</p>
<p>结果如下：</p>
<p><img src="http://img.blog.csdn.net/20161221170039609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>分析各个参数：<br>Private Clean/Dirty RAM：<br>这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。</p>
<p>PSS Total:<br>我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。<br>PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。<br>通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。</p>
<p>Dalvik Heap：<br>该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。<br>列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。</p>
<p>.so mmap / .dex mmap<br>这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。</p>
<p>上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。</p>
<hr>
<p>##DDMS</p>
<p>####使用流程</p>
<ol>
<li>启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的；</li>
<li>将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”；</li>
<li>链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息；</li>
<li>点击选中想要监测的进程，比如system_process进程；</li>
<li>点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标；</li>
<li>点击Heap视图中的“Cause GC”按钮；</li>
<li>此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。</li>
</ol>
<p>####如何检测内存泄漏？<br>Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。<br>正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大</p>
<p>通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。</p>
<hr>
<p>##MAT<br>然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。<br>要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。<br>在了解MAT具体使用之前，要先了解一些相关概念。</p>
<p>####支配树<br>支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。<br><img src="http://img.blog.csdn.net/20161221162517783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。<br>对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。</p>
<p>####SHALLOWHEAP和RETAINED HEAP<br>Shallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。<br>Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。<br>在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：<br>Shallow Size<br>对象自身占用的内存大小，不包括它引用的对象。<br>针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。<br>针对数组类型的对象，它的大小是数组元素对象的大小总和。<br>Retained Size<br>Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图：<br><img src="http://img.blog.csdn.net/20161221162603846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>A对象的Retained Size=A对象的Shallow Size<br>B对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size<br>因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 </p>
<p>以上概念，都是在使用MAT进行内存分析经常使用的。<br>我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。<br>然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。</p>
<p>在使用MAT分析内存泄漏的过程中，主要流程就是：<br>1、分析retained heap，找一个使很多对象无法被释放的内存。<br>2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。</p>
<p>####MAT的下载与使用<br>下载地址：<a href="https://eclipse.org/mat/downloads.php" target="_blank" rel="external">https://eclipse.org/mat/downloads.php</a><br>这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。<br>首先，在DDMS中选择要检测的进程并dump HPROF file，如下图：<br><img src="http://img.blog.csdn.net/20161221162702141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。</p>
<p>转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。</p>
<p>使用方法：<br>/.hprof-conv.exe a.hprof b.hprof<br>a 是输入hprof文件名，b是输出文件名。<br>然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。<br>如下：</p>
<p><img src="http://img.blog.csdn.net/20161221162902065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>####利用MAT分析内存泄漏<br>分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。</p>
<p>在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。</p>
<p><img src="http://img.blog.csdn.net/20161221163017644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。<br>在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。</p>
<p>Retained heap表示因为这个对象，会导致多少对象无法回收。</p>
<p>右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。<br>outcoming reference就是子节点，查看一些当前对象引用着的对象。</p>
<p>此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。</p>
<hr>
<p>##实战分析<br>下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。</p>
<p>###<strong>1、使用DDMS查看内存</strong><br>使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：<br>使用前：</p>
<p><img src="http://img.blog.csdn.net/20161221163735725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>使用后：<br><img src="http://img.blog.csdn.net/20161221163758204?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。</p>
<p>但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。</p>
<p>下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析：</p>
<p><img src="http://img.blog.csdn.net/20161221163820413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>###<strong>2、使用MAT分析内存转储</strong><br>前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比：<br><img src="http://img.blog.csdn.net/20161221163853538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>点击右上角的红色叹号：</p>
<p><img src="http://img.blog.csdn.net/20161221163913815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161221163927347?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。<br>再看一下使用前后直方图中的retained heap：</p>
<p><img src="http://img.blog.csdn.net/20161221163953316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。<br>右击直方图中的NewActivity，可以看见如下选项：</p>
<p><img src="http://img.blog.csdn.net/20161221164008175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>用的比较多的是List objects和Merger shortest Paths to GC Roots。<br>List objects：<br>Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。<br>Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。</p>
<p>Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。</p>
<p>在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用：</p>
<p><img src="http://img.blog.csdn.net/20161221164043992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>排除系统的对象，还是主要分析我们编写的程序。</p>
<p><img src="http://img.blog.csdn.net/20161221164100833?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。</p>
<p>去掉LeakCanary，再次测试发现data object的值确实下降了不少。</p>
<p>继续分析，发现newActivity引用了一个</p>
<p><img src="http://img.blog.csdn.net/20161221164146461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。<br>接下来，在直方图中过滤出服务端的类：<br><img src="http://img.blog.csdn.net/20161221164222647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。</p>
<p>##结论<br>在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。&lt;br&gt;本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。&lt;br&gt;撰写过程中，本人深感JVM、操作系统相关知识
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KMP算法小探</title>
    <link href="http://mryy.com/2016/12/20/KMP%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8E%A2/"/>
    <id>http://mryy.com/2016/12/20/KMP算法小探/</id>
    <published>2016-12-20T15:08:49.000Z</published>
    <updated>2017-04-20T02:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP算法题解"><a href="#KMP算法题解" class="headerlink" title="KMP算法题解"></a>KMP算法题解</h2><p>题目是leetcode上的Implement strStr()，题目大意就是在字符串haystack中寻找字符串needle的是否存在，并返回位置。<br>地址是：<br><a href="https://leetcode.com/problems/implement-strstr/，可以用来训练一下KMP算法的实现。" target="_blank" rel="external">https://leetcode.com/problems/implement-strstr/，可以用来训练一下KMP算法的实现。</a></p>
<p>学习KMP算法的过程中，参考了这篇文章：<br><a href="http://blog.csdn.net/yutianzuijin/article/details/11954939/" target="_blank" rel="external">http://blog.csdn.net/yutianzuijin/article/details/11954939/</a></p>
<p>KMP算法的核心原理在于：传统的字符串匹配，一旦发生失配，那么模式字符串直接回退到最开始。但是在KMP算法中，我们根据模式字符串的特征，在失配的时候，根据已有信息尽可能少的回退。</p>
<p>这个信息就是：<strong>模式字符串的最长公共前后缀</strong>。比如说一个长度为4的字符串abab，那么最长公共前后缀就是ab，从左边数有个ab，右边也有个ab，长度为2。一旦匹配到最右边的b后发生失配，比如模式：ababc，文本：ababd，因为模式长度为4的部分左右对称，所以不需要全部回退，回退到左边的ab即可。<br>这个信息也就是存在最长公共前后缀中，我们用一个next数组来表示。比如next[4] = 2，就是长度为2的字符串最长前后缀值为2，于是回退到2即可，也就是ab后的下一个字符。</p>
<p>next数组计算方法：引用参考文章中的说明：</p>
<blockquote>
<p>next数组计算<br>理解了kmp算法的基本原理，下一步就是要获得字符串f每一个位置的最大公共长度。这个最大公共长度在算法导论里面被记为next数组。在这里要注意一点，next数组表示的是长度，下标从1开始；但是在遍历原字符串时，下标还是从0开始。假设我们现在已经求得next[1]、next[2]、……next[i]，分别表示长度为1到i的字符串的前缀和后缀最大公共长度，现在要求next[i+1]。由上图我们可以看到，如果位置i和位置next[i]处的两个字符相同（下标从零开始），则next[i+1]等于next[i]加1。如果两个位置的字符不相同，我们可以将长度为next[i]的字符串继续分割，获得其最大公共长度next[next[i]]，然后再和位置i的字符比较。这是因为长度为next[i]前缀和后缀都可以分割成上部的构造，如果位置next[next[i]]和位置i的字符相同，则next[i+1]就等于next[next[i]]加1。如果不相等，就可以继续分割长度为next[next[i]]的字符串，直到字符串长度为0为止。由此我们可以写出求next数组的代码（Java版）：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String b)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len=b.length();</div><div class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> next[]=<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];<span class="comment">//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始</span></div><div class="line">    next[<span class="number">0</span>]=next[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)<span class="comment">//i表示字符串的下标，从0开始</span></div><div class="line">    &#123;</div><div class="line">    <span class="comment">//j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置。 这句注释一定要结合上面的说明理解，理解了KMP算法基本也就搞定了。</span></div><div class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j];</div><div class="line">        <span class="keyword">if</span>(b.charAt(i)==b.charAt(j))j++;</div><div class="line">        next[i+<span class="number">1</span>]=j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这份代码中比较难理解的就是while循环，再举一个例子，比如模式字符串：<br>ababeababc，当我们计算了前九个字符，有next[9] = 4，也就是前9字符最长公共缀为abab。（注意next[9]表明字符串长度，而4是索引，也就是第五个字符，这块有点绕要注意理解）那么现在开始计算next[10]，可以看到 j = next[9] = 4,string[4] != string[9]，看这个时候next[4]是什么，是左边abab字符串的最长公共缀ab！由于abab中左右ab是对称的，这个时候最左边的ab加上一个a，和最右边的ab加上string[9]也就是c，有可能组成新的更长的公共前缀（当然本例中a!=c，所以不存在，继续拆分）。这就是计算next的精髓，通过j=next[j]加速寻找。因为要的到更长的最长公共缀，那么i之前和j之前的字符串必须是对应的。再举个例子 dabdabcdabdabd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> d a b d a b c d a b d a b d</div><div class="line">             j             i    ，i和j处字符不同，回退</div><div class="line">       j                   i    ,回退到next[j］，字符相同</div><div class="line"> d a b d             d a b d    ,生成公共缀next[i+1]=j。</div><div class="line">可以看到，左边和右边除了i，j位置外用到的字符串，实际上是</div><div class="line">d a b d a b  的最长公共缀 d a b，如果没有回退到next[j]，即使i和j字符相同，剩余的部分也无法匹配。</div></pre></td></tr></table></figure>
<p>有点类似于一个递归的过程，只不过在递归过程中，<strong>我们不断移动j指针，使它指向可能存在结果的最长公共前缀的下一个字符，并和当前处理到的字符对比，来计算出新的next值</strong></p>
<p>本题解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] next = getNext(needle);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&lt;haystack.length()&amp;&amp; j &lt; needle.length())&#123;</div><div class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(j != <span class="number">0</span>)&#123;</div><div class="line">                    j = next[j];</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(j == needle.length()) <span class="keyword">return</span> i - needle.length();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> len=b.length();</div><div class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> next[]=<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</div><div class="line">        next[<span class="number">0</span>]=next[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j];</div><div class="line">            <span class="keyword">if</span>(b.charAt(i)==b.charAt(j))j++;</div><div class="line">            next[i+<span class="number">1</span>]=j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="KMP-算法两种写法"><a href="#KMP-算法两种写法" class="headerlink" title="KMP 算法两种写法"></a>KMP 算法两种写法</h2><p>KMP算法可以用来匹配模式字符串，或者寻找最小重复单元，比如abcabcabc，最小重复单元就是abc。qweqweqwe，最小重复单元是qwe。寻找最小重复单元就是计算出字符串的最长公共前缀的长度a，如果 a != 0 &amp;&amp; len %(len-a) == 0即找到最小重复单元。</p>
<p>详细内容见<a href="http://blog.csdn.net/yy254117440/article/details/53129175" target="_blank" rel="external">KMP算法</a><br>核心在于next数组的计算，因此列出getNext的不同计算方法。</p>
<h2 id="1、next-i-表示长度为i的字符串最长公共前缀值"><a href="#1、next-i-表示长度为i的字符串最长公共前缀值" class="headerlink" title="1、next[i]表示长度为i的字符串最长公共前缀值"></a>1、next[i]表示长度为i的字符串最长公共前缀值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String b)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> len=b.length();</div><div class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> next[]=<span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];<span class="comment">//next表示长度为i的字符串前缀和后缀的最长公共部分，从1开始</span></div><div class="line">        next[<span class="number">0</span>]=next[<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)<span class="comment">//i表示字符串的下标，从0开始</span></div><div class="line">        &#123;</div><div class="line">        <span class="comment">//j在每次循环开始都表示next[i]的值，同时也表示需要比较的下一个位置。 这句注释一定要结合上面的说明理解，理解了KMP算法基本也就搞定了。</span></div><div class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b.charAt(i)!=b.charAt(j))j=next[j];</div><div class="line">            <span class="keyword">if</span>(b.charAt(i)==b.charAt(j))j++;</div><div class="line">            next[i+<span class="number">1</span>]=j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>##2、next[i]表示字符串[0,i]，即下标。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</div><div class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; s.length()) &#123;</div><div class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) next[i++] = ++j;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) next[i++] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> j = next[j - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种下标的写法比较简洁，next[i]表示字符串 [0,i]的最长公共缀。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法题解&quot;&gt;&lt;a href=&quot;#KMP算法题解&quot; class=&quot;headerlink&quot; title=&quot;KMP算法题解&quot;&gt;&lt;/a&gt;KMP算法题解&lt;/h2&gt;&lt;p&gt;题目是leetcode上的Implement strStr()，题目大意就是在字符串haystack
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树常见问题整理</title>
    <link href="http://mryy.com/2016/11/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://mryy.com/2016/11/20/二叉树常见问题整理/</id>
    <published>2016-11-20T15:11:29.000Z</published>
    <updated>2017-04-20T02:12:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>做leetcode二叉树的题目做了不少，觉得有必要总结一下。因为题型多归多，但其实无非就是dfs和bfs，总结一些常见的解法，对于加深这两周算法的理解很有帮助。<br>在做dfs的时候，主要思路是可以从上到下也可以从下到上，也就是分析每一个子树的根节点，然后分析该子树的内部子树或者外部子树的根节点，以此得出递归关系，也即是分治的思想。同时，对于每个节点的处理尝试利用前序、后序、中序遍历三种方法。<br>做bfs的时候，主要思路是从上到下，一层一层进行分析。</p>
<hr>
<p>##构建二叉树<br>leetcode 105和106题</p>
<blockquote>
<p>1、利用前序和中序遍历构建二叉树。<br>构建一棵二叉树，如果是通过dfs的方式的话，那么分析每一个子树的根节点，将一个大子树分解成一个一个小的子树，分治下去，也就可以得出递归。<br>比如，有前序1，2，4，5，3，中序4，2，5，1，3。从前序中，我们可以得出一个条件：当前子树的根节点。<br>对于整个子树1，2，4，5，3，可以确定，1是该子树根节点，然后去中序中找1，1的左边是4，2，5，右边是3。因为中序的性质是在遍历完左子树后遍历当前根节点，所以说4，2，5就是1为父节点的一个新的子树。去前序中得到一个新的前序+中序数组对：2，4，5；  4，2，5，同理，2是该子树根节点，4是左子树，5在右子树， 以此类推分治递归下去。<strong>找到递归关系后，每一层根节点完成当前任务，然后将构建子树的任务交给左右子树递归过程即可。</strong>同时，我们思考的过程是从上到下，但程序递归运行的过程是从下到上，这点需要注意。可以写出代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (preorder.length != inorder.length) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (preorder.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//完成当前任务，构建当前子树根节点。</span></div><div class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) <span class="keyword">return</span> node;</div><div class="line">        <span class="keyword">int</span> root = preorder[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> leftCount=<span class="number">0</span>;</div><div class="line">        <span class="comment">//找到根节点位置</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;inorder.length;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (inorder[i] == root)&#123;</div><div class="line">                leftCount = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将新的构建任务递归交下去。</span></div><div class="line">        node.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, leftCount+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,leftCount));</div><div class="line">        node.right = buildTree(Arrays.copyOfRange(preorder, leftCount + <span class="number">1</span>, preorder.length ), Arrays.copyOfRange(inorder, leftCount + <span class="number">1</span>, inorder.length ));</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2、利用后序和中序构建二叉树。<br>思路类似，还是先找根节点！可以看到，当前整个子树根节点可以通过后续确定，然后利用中序确定左右子树来分治递归。思路类似。</p>
</blockquote>
<hr>
<p>##构建二叉搜索树 BST<br>leetcode 108和109题</p>
<blockquote>
<p>1、通过有序数组来构建一棵平衡二叉搜索树。</p>
</blockquote>
<p>首先，对于一个有序数组，比如1，2，3，4，5，6。这里采用dfs解题。前面说过分析dfs时针对每一个子树的根节点，通过各个子树的根节点来寻找递归关系。<br>对于BST最上面的子树，根节点就是有序数组最中间的元素，令s = 0，e = 5，那么mid = s +(e-s)/2 = 2。也就是3是整个子树根节点，1，2是左子树内容，4，5，6是右子树内容。对于1，2有s = 0，e = 1，同理mid = 0，也就是1是该子树根节点，2是右子树内容。 以此类推很容易写出递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(s &gt; e) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">int</span> mid = s + (e-s)/<span class="number">2</span>;</div><div class="line">	TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</div><div class="line">	root.left = dfs(s,mid-<span class="number">1</span>,nums);</div><div class="line">	root.right = dfs(mid+<span class="number">1</span>,e,nums);</div><div class="line">	<span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，建议画出递归栈，方便理解。<strong>在思考递归时，是从上到下思考，由整体到局部，但是程序运行时从下到上的，也就是dfs运行方式。</strong>是通过前序遍历的方式，在数组中依次拿出2，1，3，4，5，从下到上构建出BST，构建顺序是dfs的前序方式。</p>
<blockquote>
<p>2、通过有序链表来构建一棵平衡二叉搜索树。<br>链表和数组不同了，数组可以随机访问，而链表只能顺序访问。所以，我们的思路应该是，依次将1，2，3，4，5填到BST的正确位置。利用类似1中的dfs，可以得到下图的递归栈，也就是说这5个符合条件的点就是BST中的点。我们从链表中依次拿出1，2，3，4，5，填入到这个树结构并构造BST。可以看到，对于1，应该填在0-&gt;1的位置，2填在1-&gt;1的位置，然后3填在0-&gt;4，4填在3-&gt;4，其实也就是以<strong>中序遍历</strong>的顺序填进去。这样一来，代码也就出来了：<br><img src="http://img.blog.csdn.net/20161122190249168" alt="这里写图片描述"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s &gt; e) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> mid = s + (e -s )/<span class="number">2</span>;</div><div class="line">    TreeNode left = dfs(s, mid - <span class="number">1</span>);</div><div class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(head.val);</div><div class="line">    head = head.next;</div><div class="line">    TreeNode right = dfs(mid + <span class="number">1</span>, e);</div><div class="line">    node.left = left;</div><div class="line">    node.right = right;</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>可以看到，在构建树或者BST的过程中，找准根节点位置以及填放顺序，来相应处理即可。</p>
<hr>
<p>##按层级遍历问题<br>leetcode 102，103，107都是此类问题，此类问题十分简单，可以采用bfs和dfs求解。</p>
<blockquote>
<p>将一棵二叉树按层级遍历。<br><img src="http://img.blog.csdn.net/20161122192518107" alt="这里写图片描述"><br>如果使用bfs，遍历完一层后可以得到下一次的全部节点数，在每一次遍历后一次性遍历整个一层即可。<br>代码类似：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">queue.add(root);</div><div class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</div><div class="line">	<span class="keyword">int</span> size = queue.size();</div><div class="line">	<span class="comment">//利用for循环，一次性遍历一个层级。</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</div><div class="line">		TreeNode cur = queue.poll();</div><div class="line">		queue.add(cur.left);</div><div class="line">		queue.add(cur.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用dfs，我们无法保证一个层级的全部节点是同一时刻遍历的，但是可以分时遍历，也就是在dfs中添加一个关于level的参数，将同一level的点加入到结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dfs(TreeNode root,<span class="keyword">int</span> level)&#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span> ) <span class="keyword">return</span>;</div><div class="line">	<span class="comment">//将当前节点添加到结果中</span></div><div class="line">	result.get(level).add(root);</div><div class="line">	dfs(root.left,level+<span class="number">1</span>);</div><div class="line">	dfs(root.right,level + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，利用level将节点添加到结果链表相应位置，不管是正序，倒叙还是ZigZag，都是相应计算的事，所以还是比较推荐dfs，简单整洁。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做leetcode二叉树的题目做了不少，觉得有必要总结一下。因为题型多归多，但其实无非就是dfs和bfs，总结一些常见的解法，对于加深这两周算法的理解很有帮助。&lt;br&gt;在做dfs的时候，主要思路是可以从上到下也可以从下到上，也就是分析每一个子树的根节点，然后分析该子树的内部
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划简介</title>
    <link href="http://mryy.com/2016/10/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B/"/>
    <id>http://mryy.com/2016/10/29/动态规划简介/</id>
    <published>2016-10-29T13:56:31.000Z</published>
    <updated>2017-04-19T14:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。</p>
<hr>
<p>#解题思路<br>在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新的元素和已有结果是否存在某种关系。<br>对于没有思路的题目，求解可以分为暴力递归（回溯），记忆性搜索，递归优化，时间或空间最终优化四个阶段。<br>在碰到一道可以使用动态规划的题目的时候，如果还不知道怎么下手，那么第一步，一定要去想如何递归求解。<br>所谓递归求解，说的简单点，就是一种穷举，文艺一点，也可以叫回溯。是的，在学习动态规划之前，一定要对回溯法有所了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">backtracking(member)&#123;</div><div class="line">	//如果已经不可能再得到结果，直接返回。也叫剪枝，分支限界。</div><div class="line">	if(is_invalid) return;</div><div class="line">	//如果得到最终结果，处理显示。</div><div class="line">	if(is_solution) print_result();</div><div class="line">	//递归即将进入下一层级，如果有数据在下一层级中需要使用，更新它们。</div><div class="line">	move_ahead();</div><div class="line"></div><div class="line">	//准备要进入递归的元素。</div><div class="line">	candidate[] candidates = get_candidates;</div><div class="line">	for(candidate in candidates)&#123;</div><div class="line">		backtracking(candidate)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//递归回到当前层级，将数据更新回当前层级所需数据。</div><div class="line">	move_back();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是回溯法的基本模板，看清来可能有点模糊，下面的第一道题目的第一个步骤，就将对此作出详细解释。</p>
<p>##题目1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">给一个非负数组，你一开始处在数组收尾（index=0），数组中元素代表你能从当前位置向后跳的**最大**步数，问能否达到数组末尾。比如：</div><div class="line">A = [2,3,1,1,4], return true.</div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure>
<p>###递归求解</p>
<p>最为直观的回溯法求解如下：<br>思路十分直观，当我们到了每个位置，在此位置上，可以向后跳1到最大步数，在每一跳之后进行递归，依次类推穷举出所有情况，一旦有一种可以到达最终位置，那么我们就可以得到最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</div><div class="line">        if (position == nums.length - 1) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</div><div class="line">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</div><div class="line">            if (canJumpFromPosition(nextPosition, nums)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        return canJumpFromPosition(0, nums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先进行一下简单的优化，在每一步判断下一跳位置的时候，为了尽快的到达最后的位置，我们很明显应该尽可能多走步数，一旦发现最后无法到达再减少步数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原始代码</div><div class="line">for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++)</div><div class="line">// 新的代码</div><div class="line">for (int nextPosition = furthestJump; nextPosition &gt; position; nextPosition--)</div></pre></td></tr></table></figure>
<p>###记忆化搜索（自顶向下动态规划）<br>可以看到，上面的递归基本就是暴力解法，那么进一步的优化，就是在递归上面应用存储，已经计算过的分支不再继续进行计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    Index[] memo;</div><div class="line"></div><div class="line">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</div><div class="line">    //存储已经计算过的分支</div><div class="line">        if (memo[position] != Index.UNKNOWN) &#123;</div><div class="line">            return memo[position] == Index.GOOD ? true : false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</div><div class="line">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</div><div class="line">            if (canJumpFromPosition(nextPosition, nums)) &#123;</div><div class="line">                memo[position] = Index.GOOD;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        memo[position] = Index.BAD;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        memo = new Index[nums.length];</div><div class="line">        for (int i = 0; i &lt; memo.length; i++) &#123;</div><div class="line">            memo[i] = Index.UNKNOWN;</div><div class="line">        &#125;</div><div class="line">        memo[memo.length - 1] = Index.GOOD;</div><div class="line">        return canJumpFromPosition(0, nums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###去递归（自底向上动态规划）<br>去递归的过程，其实就是人为的分析并指定计算过程的过程。<br>首先分析递归过程中的<strong>可变参数</strong>，这个可变参数就是循环中遍历的变量。这里很明显是当前位置 position。<br>然后需要分析递归的运行顺序，这里可以人为画递归树。我们可以发现，运算实质是从右向左进行的。一个点能否达到某一个点，取决于它右边点的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">enum Index &#123;</div><div class="line">    GOOD, BAD, UNKNOWN</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        Index[] memo = new Index[nums.length];</div><div class="line">        for (int i = 0; i &lt; memo.length; i++) &#123;</div><div class="line">            memo[i] = Index.UNKNOWN;</div><div class="line">        &#125;</div><div class="line">        memo[memo.length - 1] = Index.GOOD;</div><div class="line"></div><div class="line">        for (int i = nums.length - 2; i &gt;= 0; i--) &#123;</div><div class="line">            int furthestJump = Math.min(i + nums[i], nums.length - 1);</div><div class="line">            //去当前点的右边看是否有可达点。</div><div class="line">            for (int j = i + 1; j &lt;= furthestJump; j++) &#123;</div><div class="line">                if (memo[j] == Index.GOOD) &#123;</div><div class="line">                    memo[i] = Index.GOOD;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return memo[0] == Index.GOOD;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###贪心优化（贪心策略）<br>上面的时间复杂度为O（mn），m是数组中最大值，n是数组个数。在分析上面循环的过程中，我们发现找到的第一个点可以到达一个可达点，那么当前位置就不需要再判断后面的步数。也就是说，一个点只要找到离他最近的可达点，那么它就变成了下一轮的可达点。下一轮一旦有一个点可以达到它，那么该点又成为下一轮新的可达点。<br>这也就告诉我们，对于每个点，只要找到它右边第一个可达点即可。<br>这也就是典型的贪心策略。<br>我们可以从右向左，在某个可达点左边找一个最近的点可以达到它，更新该最近点为新的可达点，以此类推，知道最后的一个可达点是起始点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        int lastPos = nums.length - 1;</div><div class="line">        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (i + nums[i] &gt;= lastPos) &#123;</div><div class="line">                lastPos = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return lastPos == 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##题目2<br>给一个非负数组，从数组中选取任意个数字求和，要求所选元素均不相邻，求最大和。</p>
<p>###直接寻找递归关系<br>对于比较简单的dp，也可以寻找递推关系求解：<br>这到题的递推关系在于，对于每一个新的元素，都可以选择取或者不取，用一个数组dp记录前面不同长度数组的最大和，那么对当前元素dp[i]，如果不取则最大和为dp[i-1],如果取则最大值为dp[i-2]+num[i];可以很轻易的根据递推关系写出动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] dp = new int[nums.length+1];</div><div class="line">        dp[0] = 0;</div><div class="line">        dp[1] = nums[0];</div><div class="line">		for(int i = 2;i&lt;nums.length;i++)&#123;</div><div class="line">			dp[i] = Math.max(dp[i-1],nums[i]+dp[i-2]);</div><div class="line">		&#125;</div><div class="line">		return dp[nums.length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同经典的钢条切割背包问题一样， <strong>对于一个新出现的元素，选与不选是构成递归的重要策略</strong>。比如leetcode两道题目 ：<a href="https://leetcode.com/problems/house-robber/，" target="_blank" rel="external">https://leetcode.com/problems/house-robber/，</a><br><a href="https://leetcode.com/problems/house-robber-ii/，" target="_blank" rel="external">https://leetcode.com/problems/house-robber-ii/，</a><br>都是对于一个新出现的元素，进行选与不选两种决策去寻找递推关系，动态规划可能的O(N)解法基本也只会出现在这种决策中。</p>
<p>###空间优化<br>到这里还不算完，我们看见，对于每个dp[i]的计算，仅和dp[i-1]，dp[i-2]有关，这也告诉我们根本不需要一个数组，因为以前用过的值在后面不会再使用。这样，仅仅使用两个变量就可以达到效果，空间复杂度也从O(N)降到了O(1)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int a =0,b = nums[0];</div><div class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</div><div class="line">            int temp = b;</div><div class="line">            b = Math.max(b,a+nums[i]);</div><div class="line">            a = temp;</div><div class="line">        &#125;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##题目3<br>一个二维非负数组，找出从最左上到最右下的最小距离，只可以向右或者向下移动。</p>
<p>###直接寻找递推关系<br>这道题基本是二维中最简单的了，直接看到某一点(i,j)的最短距离怎么求就可以。用二维数组记录到每个点的最短距离dp[i][j]，可以直接根据递推关系 dp[i][j] = min{dp[i-1][j],dp[i][j-1]}就可以求解。</p>
<p>###二维空间优化<br>一维动态规划可以通过空间优化达到常数级别的空间复杂度，同样二维动态规划也可以进一步优化。<br>首先，根据递归关系，我们发现每个位置只和上面i-1和左边j-1的值有关，于是可以采用数组滚动的方法。<br>在计算第i行的时候，只存储第i－1行的最短距离，比如计算(i,j)点，数组中dp[j]到右边的元素是二维表中（i-1,j)右边的元素。而数组中 dp[j-1]以及其左边的元素，是 二维表中 (i,j-1)及其左边的元素。<br>其实，就是计算将第i行计算过的结果存在数组前半部分，而后半部分是之前计算上一行存储的最短距离，用于以后计算使用。相当于通过滚动，覆盖了不再被需要的值。<br>如下面的简图，其实就是把一个数组分成两半，左边存储dp[i][j-1]所要用的数据，右边是dp[i-1][j]使用的数据。<br><img src="http://img.blog.csdn.net/20161028143815979" alt="这里写图片描述"></p>
<p>优化过的代码如下，空间复杂度降到了O(n).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int minPathSum(int[][] grid) &#123;</div><div class="line">        //空间压缩，数组滚动方法。</div><div class="line">        int m = grid.length,n = grid[0].length;</div><div class="line">        int[] dp = new int[n];</div><div class="line">        dp[0] = grid[0][0];</div><div class="line">        for(int i=1;i&lt;n;i++)</div><div class="line">            dp[i] =dp[i-1] + grid[0][i];</div><div class="line">        for(int i=1;i&lt;m;i++)</div><div class="line">            for(int j=0;j&lt;n;j++)</div><div class="line">                dp[j] = (j&gt;0?Math.min(dp[j - 1],dp[j]):dp[j]) + grid[i][j];</div><div class="line">        return dp[n-1];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>题目4、5：<br>这两道题目是一维的动态规划，对于一维的动态规划很难从基本的暴力解法逐步推导过去，更多的是寻找递推关系，类似于钢条切割问题。个人还是比较头疼的。<br>第一个题目：<br>地址：<a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">https://leetcode.com/problems/maximum-subarray/</a><br>题目是在一个数组中，寻找连续的数，获得最大和。<br>比如：[-2,1,-3,4,-1,2,1,-5,4]数组，最大和是子数组[4,-1,2,1]为6。</p>
<p>一维动态规划，寻找递推关系。为了表明是dp问题，设置一个数组，dp[i]表示包含nums[i]的子数组的最大和。从左到右遍历数组，每新添一个数时，计算dp[i］，可以知道新添的数要么和前面最大和子数组累加，得到dp[i]＋nums[i]，要么自己作为一个新的子数组的唯一元素，和是nums[i]，则有递推关系 dp[i] ＝ max(nums[i],dp[i-1] * nums[i])。<br>注意，dp[i]是包含第i个元素的局部最优解，全局最优解每次获得局部最优解比较一下就行。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    //空间可以被优化</div><div class="line">    public int maxSubArray(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] dp = new int[nums.length];</div><div class="line">        int r = nums[0];</div><div class="line">        dp[0] = nums[0];</div><div class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</div><div class="line">            int n = nums[i];</div><div class="line">            dp[i] = Math.max(n,dp[i-1]+n);</div><div class="line">            r = Math.max(dp[i],r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>第二个题目类似，只不过是乘法最大值。乘法就是要跟踪一下局部的最大值和最小值即可，因为乘法最小值乘以负数也可能出现最大值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] max = new int[nums.length];</div><div class="line">        int[] min = new int[nums.length];</div><div class="line">        int r = nums[0];</div><div class="line">        max[0] = r;</div><div class="line">        min[0] = r;</div><div class="line">        for (int i = 1;i&lt;nums.length;i++) &#123;</div><div class="line">            int n = nums[i];</div><div class="line">            int a = max[i - 1] * n;</div><div class="line">            int b = min[i - 1] * n;</div><div class="line">            max[i] = Math.max(n, Math.max(a,b));</div><div class="line">            min[i] = Math.min(n, Math.min(a, b));</div><div class="line">            r = Math.max(max[i], r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显，两个题目都可以优化成O（1）空间，这里为了表示明显不进行优化，读者可以自己尝试一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#解题思路&lt;br&gt;在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android 消息系统Handler、Message、Looper</title>
    <link href="http://mryy.com/2016/09/20/android-%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9FHandler%E3%80%81Message%E3%80%81Looper/"/>
    <id>http://mryy.com/2016/09/20/android-消息系统Handler、Message、Looper/</id>
    <published>2016-09-20T02:05:34.000Z</published>
    <updated>2017-04-20T02:07:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>##android消息系统<br>整体框架如图所示<br><img src="http://img.blog.csdn.net/20160818212025978" alt="这里写图片描述"><br>在安卓的消息系统中，每个线程有一个Looper，Looper中有一个MessageQueue，Handler向这个队列中投递Message，Looper循环拿出Message再交由Handler处理。整体是一个生产者消费者模式，这四部分也就构成了android的消息系统。<br>先来看一个最简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这段代码在某个Activity的onCreate中</span></div><div class="line">      Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">      Message msg = Message.obtain(handler, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              Toast.makeText(getApplicationContext,<span class="string">"I am a message"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      handler.sendMessage(msg);</div></pre></td></tr></table></figure>
<p>效果就是，在当前窗口弹出I am a message，当然就其实现的效果而言完全多此一举。但是就分析android消息系统，却是很简单有效的例子。</p>
<hr>
<p>##源码分析</p>
<p>###Message<br>Message中封装了我们常用的what、arg1、arg2、obj等参数，除此之外还有target：一个Handler类型，由前文可知一个Message最终还是交给一个Handler执行的，这个target存放的就是消息的目的地、callback，一个消息的回调，我们通过handler.post(new Runnable{…})发送的消息，这个Runnable即被存为callback。<br>首先来看消息的获取：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</div><div class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = <span class="keyword">null</span>;</div><div class="line">            sPoolSize--;</div><div class="line">            <span class="keyword">return</span> m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;</div><div class="line">    Message m = obtain();</div><div class="line">    m.target = h;</div><div class="line">    m.callback = callback;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对照最开始的例子，Message.obtain(Handler h, Runnable callback)首先调用obtain获取了一个新的Message对象，然后为其设置了目的地Handler和回调函数callback，Message类中有很多不同的obtain函数，实际上只是为我们封装了一些赋值的操作。</p>
<p>再看Message.obtain()方法，sPoolSync是一个给静态方法用的静态锁，sPool是一个静态的Message变量，在消息的获取这里，android使用了<strong>享元模式</strong>，对于会被重复使用的Message消息，没有对每一次请求都新建一个对象，而是通过维护一个Message链表，在有空闲消息的时候从链表中拿Message，没有时才新建Message。<br>可以看到obtain中只有从链表中去Message和新建Message，而没有向链表中存储的过程。存储这部分就要看Message.recycle()了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void recycle() &#123;</div><div class="line">    clearForRecycle();</div><div class="line"></div><div class="line">    synchronized (sPoolSync) &#123;</div><div class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class="line">            next = sPool;</div><div class="line">            sPool = this;</div><div class="line">            sPoolSize++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回收过程，首先把原链表的头指向当前被回收消息的下一个节点，然后再把链表头指针知道当前节点即可。整个操作也就是将Message添加到链表的首位。</p>
<hr>
<p>###MessageQueue 消息队列<br>MessageQueue是在Looper中的，这点从Looper的构造函数可以看出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">        mQueue = new MessageQueue(quitAllowed);</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于每个MessageQueue，是链表实现的消息队列。首先是入队操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Message must have a target."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">                Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.when = when;</div><div class="line">            <span class="comment">//mMessages是链表的头指针</span></div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">                <span class="comment">// 将消息插入到队列的首位</span></div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                <span class="keyword">for</span> (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    <span class="comment">//当抵达队列尾部、或者当前消息的时间小于队列中某消息的时间跳出循环</span></div><div class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将消息插入到链表中间（包含尾部）</span></div><div class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">            <span class="keyword">if</span> (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>next操作，包含取出和删除一条消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//从native层消息队列取出消息</span></div><div class="line">            nativePollOnce(mPtr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 找到非异步的Message或者消息队列尾部的Message取出</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                        <span class="comment">// 消息尚未到执行时间，下次循环挂起线程一段时间</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// 获取一个Message</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mMessages = msg.next;</div><div class="line">                        &#125;</div><div class="line">                        msg.next = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// No more messages.</span></div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 检查退出标志位</span></div><div class="line">                <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">				...</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>###Handler<br>Handler的作用是放入消息和处理消息，承担了生产者的工作和部分消费者的工作。<br>首先通过Handler发送一条消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>通过一层一层嵌套，真正的逻辑在sendMessageAtTime，可以看到仅仅是执行了一下入队操作。作为生产者的工作也就执行完成，消费者部分后面要结合Looper分析。<br>除了sendMessage方法，常用的handler.post方法也是封装为Message，主要过程和上面相似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></div><div class="line">    &#123;</div><div class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        Message m = Message.obtain();</div><div class="line">        m.callback = r;</div><div class="line">        <span class="keyword">return</span> m;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>###Looper<br>Looper类中，Looper的实例获取是通过ThreadLocal的，ThreadLocal会为每一个线程提供一个副本，通过set和get方法每个线程获取作用域仅属于该线程的变量值。对于UI线程而言，会执行Looper.prepareMainLooper()来完成Looper的初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>Looper.prepare()方法将当前线程的ThreadLocal设置了一个新的Looper对象，prepareMainLooper则是把当前线程的Looper对象赋值给类变量sMainLooper ，该方法在ActivityThread中调用，设置了一个全局的给UI线程使用的Looper。</p>
<p>Looper的loop方法就是消费者的处理逻辑了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line"></div><div class="line">        Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line">		<span class="comment">//从Looper中获取MessageQueue，循环取出消息</span></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            Message msg = queue.next();</div><div class="line">            </div><div class="line">            ...</div><div class="line"></div><div class="line">			<span class="comment">//将消息发送给目标处理。</span></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">			</div><div class="line">			...</div><div class="line">			</div><div class="line">			<span class="comment">//回收消息，把消息放在消息池中</span></div><div class="line">            msg.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>主要逻辑很清晰，前面分析过msg.target是一个Handler，表示处理消息的目标，通过<strong>命令模式</strong>将消息交给对应Handler处理。下面是Handler中处理消息的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        message.callback.run();</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果我们是通过handler.post的方法发送一条消息，那么直接执行callback中的逻辑。否则通过实现Callback接口回调，或者执行handleMessage，handleMessage也就是我们子类覆写的方法。可以看到，虽然逻辑部分是我们在Handler中实现的，但是调用的地方却是Looper的线程。因为一个Looper绑定一个线程，我们也可以通过比较Looper来比较线程。</p>
<hr>
<p>##总结<br>通过分析源码，可以知道android中可以通过Looper为每一个线程创建一个消息队里，UI线程的Looper在Activity启动前就已经初始化。那么对于我们自定义的线程，很明显也可以绑定Looper。<br>自定义线程绑定Looper，最明显的好处就是可以实现线程间通信了，同时由于借助了消息队列，也将并行转为串行实现了线程安全。看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper.prepare();</div><div class="line">        handlerA = <span class="keyword">new</span> Handler(Looper.myLooper())&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                Log.d(<span class="string">"TAG"</span>, msg.obj.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>上述在线程中创建绑定了一个Looper，然后新建一个和当前Looper绑定的Handler，这样可以通过该Handler向Looper的MessageQueue中添加消息，然后由Looper.loop取出消息并执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Message msg = <span class="keyword">new</span> Message();</div><div class="line">msg.obj = <span class="string">"i am main thread"</span>;</div><div class="line">handlerA.sendMessage(msg);</div></pre></td></tr></table></figure>
<p>在主线程或者其它线程中获取handler然后发送消息，最终可以看到消息被线程接收并处理。这里msg的target也就是handlerA。注意如果线程工作结束，需要调用Looper.quit()，不然会因为Looper一直循环而导致线程无法结束。</p>
<p>最后经过上面的分析，流程图可以画的更为细致：</p>
<p><img src="http://img.blog.csdn.net/20160819110639532" alt="这里写图片描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##android消息系统&lt;br&gt;整体框架如图所示&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160818212025978&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;在安卓的消息系统中，每个线程有一个Looper，Looper中有一个Me
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Volley源码分析</title>
    <link href="http://mryy.com/2016/08/18/Volley%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mryy.com/2016/08/18/Volley源码分析/</id>
    <published>2016-08-18T02:04:45.000Z</published>
    <updated>2017-04-20T02:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Volley基本使用"><a href="#Volley基本使用" class="headerlink" title="Volley基本使用"></a>Volley基本使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//声明一个请求队列，请求队列最好全局唯一。</div><div class="line">      RequestQueue mQueue = Volley.newRequestQueue(context);</div><div class="line">      //请求的错误回调</div><div class="line">      Response.ErrorListener errorListener = new Response.ErrorListener() &#123;</div><div class="line">          @Override</div><div class="line">          public void onErrorResponse(VolleyError volleyError) &#123;</div><div class="line">          ...</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">//请求的正确回调</div><div class="line">Response.Listener listener = new Response.Listener() &#123;</div><div class="line">          @Override</div><div class="line">          public void onResponse(Object o) &#123;</div><div class="line">              </div><div class="line">              </div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">//封装好的请求</div><div class="line">      StringRequest stringRequest = new StringRequest(Request.Method.POST, url, listener, errorListener) &#123;</div><div class="line"></div><div class="line">              @Override</div><div class="line">              protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123;</div><div class="line">                  // TODO Auto-generated method stub</div><div class="line">                  if (request.isEmpty())</div><div class="line">                      return super.getParams();</div><div class="line">                  else &#123;</div><div class="line">                      return request;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">          &#125;;</div><div class="line">      //将封装好的请求加入到请求队列中去</div><div class="line">      mQueue.add(stringRequest);</div></pre></td></tr></table></figure>
<hr>
<p>##整体框架<br><img src="http://img.blog.csdn.net/20160818160144214" alt="这里写图片描述"></p>
<p>Volley整体框架如上图所示，是一个典型的生产者消费者模式。主要可以分成三个部分，一个是封装好的Request，包含请求的类型等等，然后将其投入到RequestQueue中，之后有一个用于分发请求的线程Dispatcher，进行网络请求的执行和回调。下面分部分分析：<br>关键类的UML图，主要四个类为：请求Request、响应Response、网络执行工人线程NetWorkExecutor、结果UI线程回调ResponseDelivery<br><img src="http://img.blog.csdn.net/20161024115135411" alt="这里写图片描述"></p>
<hr>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p><img src="http://img.blog.csdn.net/20160818161232666" alt="这里写图片描述"><br>抽象父类Request，有多个不同种类的Request。StringRequest的构造器调用父类构造器，在Request中存储http请求的方式，Url和失败回调的地址。成功的回调是一个泛型接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface Listener&lt;T&gt; &#123;</div><div class="line">    /** Called when a response is received. */</div><div class="line">    public void onResponse(T response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将类型参数赋值为String，然后将接口实现并存储在StringRequest中的mListener中。在Request中另有抽象方法parseNetworkResponse和deliverResponse，子类实现，后面消费者消费Request时候，调用parseNetworkResponse解析原始的响应，然后调用deliverResponse分发给UI线程。<br>StringRequest的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123;</div><div class="line">        String parsed;</div><div class="line">        try &#123;</div><div class="line">            parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            parsed = new String(response.data);</div><div class="line">        &#125;</div><div class="line">        return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>将网络响应的报文体直接按字符串转换，封装进Response返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void deliverResponse(String response) &#123;</div><div class="line">    if (mListener != null) &#123;</div><div class="line">        mListener.onResponse(response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后将Respone通过设置的回调接口，调用来处理客户端想要处理的逻辑。<br>这种典型的写法启示我们，在实现异步逻辑的时候，可以将客户端想要的逻辑利用接口实现，然后封装进一个实体中，当线程完成工作后调用这个实体存储的接口实现，从而客户端可以异步实现逻辑。</p>
<p>###RequestQueue<br>大致了解了封装的实体类Request后，来看一下生产者和消费者连接的部分RequestQueue。<br>调用Volley类中静态方法newRequestQueue来实例化一个RequestQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class="line">        ResponseDelivery delivery) &#123;</div><div class="line">    mCache = cache;</div><div class="line">    mNetwork = network;</div><div class="line">    mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class="line">    mDelivery = delivery;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造器中，cache是缓存文件目录，network中封装了如何将Request转化为http请求的方法performRequest，类似于策略模式。Dispatchers就是从队列中拿出Request进行网络请求的workerThread消费者，delivery默认值是new ExecutorDelivery(new Handler(Looper.getMainLooper()))，其中的handler和UI线程的Looper相连，从而可以通过handler向UI线程的消息队列发送消息更改UI，delivery也就是结果处理后的界面更改回调。<br>综上，RequestQueue中封装了Request转换为网络请求的方法，分发请求的工作线程，将结果发送给UI的传递者。<br>调用requestQueue.start()后，启动缓存线程和网络请求线程，主要分析网络请求部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">    NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">            mCache, mDelivery);</div><div class="line">    mDispatchers[i] = networkDispatcher;</div><div class="line">    networkDispatcher.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mDispachers是一个数组，类似线程池存储着工人线程。NetworkDispatcher是worker thread，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void quit() &#123;</div><div class="line">    mQuit = true;</div><div class="line">    interrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>quit方法通过interrupt和标志位中断一个线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void run() &#123;</div><div class="line">		//设置当前线程为后台线程，减少对于UI线程渲染的影响</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request&lt;?&gt; request;</div><div class="line">        while (true) &#123;</div><div class="line">            long startTimeMs = SystemClock.elapsedRealtime();</div><div class="line">            // release previous request object to avoid leaking request object when mQueue is drained.</div><div class="line">            request = null;</div><div class="line">            try &#123;</div><div class="line">                // Take a request from the queue.</div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                // We may have been interrupted because it was time to quit.</div><div class="line">                //检查标志位，看队列是否结束</div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line"></div><div class="line">                // If the request was cancelled already, do not perform the</div><div class="line">                // network request.</div><div class="line">                if (request.isCanceled()) &#123;</div><div class="line">                    request.finish(&quot;network-discard-cancelled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">                // 这里调用网络请求策略network，将Request转化为网络请求处理。获得响应封装。</div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line"></div><div class="line">				//304缓存处理。没有修改，不进行http请求维持原状。</div><div class="line">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                    request.finish(&quot;not-modified&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 将原始的网络请求解析，这里是按照StringRequest的方式解析。</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line"></div><div class="line">                //缓存相关</div><div class="line">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">                    request.addMarker(&quot;network-cache-written&quot;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // delivery，分发更改UI</div><div class="line">                request.markDelivered();</div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; catch (VolleyError volleyError) &#123;</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class="line">                VolleyError volleyError = new VolleyError(e);</div><div class="line">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class="line">                mDelivery.postError(request, volleyError);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>###Delivery<br>分发部分的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123;</div><div class="line">    request.markDelivered();</div><div class="line">    request.addMarker(&quot;post-response&quot;);</div><div class="line">    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mResponsePoster = new Executor() &#123;</div><div class="line">    @Override</div><div class="line">    public void execute(Runnable command) &#123;</div><div class="line">        handler.post(command);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ResponseDeliveryRunnable是给UI线程的Handler发送的Runnable，也就是说这部分是执行在UI线程上的，其中逻辑部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            // If this request has canceled, finish it and don&apos;t deliver.</div><div class="line">            if (mRequest.isCanceled()) &#123;</div><div class="line">                mRequest.finish(&quot;canceled-at-delivery&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 调用我们定义的Request中的listener回调</div><div class="line">            if (mResponse.isSuccess()) &#123;</div><div class="line">                mRequest.deliverResponse(mResponse.result);</div><div class="line">            &#125; else &#123;</div><div class="line">                mRequest.deliverError(mResponse.error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // If this is an intermediate response, add a marker, otherwise we&apos;re done</div><div class="line">            // and the request can be finished.</div><div class="line">            if (mResponse.intermediate) &#123;</div><div class="line">                mRequest.addMarker(&quot;intermediate-response&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                mRequest.finish(&quot;done&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // If we have been provided a post-delivery runnable, run it.</div><div class="line">            if (mRunnable != null) &#123;</div><div class="line">                mRunnable.run();</div><div class="line">            &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>可以看在，最初在Request中封装的更改UI的listener，在mRequest.deliverResponse(mResponse.result); 被异步调用并执行，并且通过ExecutorDelivery确保在UI线程中执行，ExecutorDelivery类似命令模式，dispatcher负责网络部分，Delivery负责UI部分，确保收到的每个Request响应的回调执行在UI线程中。</p>
<hr>
<p>##总结<br>作为生产者-消费者模式，客户端可以将网络请求的处理方式，获取响应后的处理逻辑封装进Request，然后放进RequestQueue中。对于一个全局的RequestQueue，维护一个工作线程池，利用多个线程从队列中去除Request去执行网络请求，根据Request中封装的网络请求方法获取Response后，将结果给Delivery。然后通过Delivery分发给UI线程，调用Request中更新的UI处理逻辑。<br>对比传统的通过新建线程实现网络请求的方式，volley采用的方式不仅逻辑清晰、易于管理，同时将线程维护、UI更新这部分不易发生变化的工作封装，用户也可通过继承Request实现扩展，增强了可维护性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Volley基本使用&quot;&gt;&lt;a href=&quot;#Volley基本使用&quot; class=&quot;headerlink&quot; title=&quot;Volley基本使用&quot;&gt;&lt;/a&gt;Volley基本使用&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
</feed>
