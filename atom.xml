<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang Yang的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mryy.com/"/>
  <updated>2017-04-19T12:41:57.000Z</updated>
  <id>http://mryy.com/</id>
  
  <author>
    <name>Yang Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus 源码分析</title>
    <link href="http://mryy.com/2017/04/19/EventBus-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mryy.com/2017/04/19/EventBus-源码分析/</id>
    <published>2017-04-19T11:15:03.000Z</published>
    <updated>2017-04-19T12:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>EventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可以方便的指定运行时的线程，提高了处理UI回调，后台线程执行任务的效率。</p>
<h2 id="register-发布过程"><a href="#register-发布过程" class="headerlink" title="register  发布过程"></a>register  发布过程</h2><p>register 主要包括两个过程：</p>
<ul>
<li>找到当前注册的对象中onEvent相关订阅方法</li>
<li>订阅者对找出的方法进行订阅。</li>
</ul>
<h3 id="findSubscriberMethods"><a href="#findSubscriberMethods" class="headerlink" title="findSubscriberMethods"></a>findSubscriberMethods</h3><p>利用反射找到onEvent开头的方法，如果有比如MainThread、BackgroundThread、Async等后缀则标识相应的ThreadMode类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (modifierString.length() == 0) &#123;</div><div class="line">                        threadMode = ThreadMode.PostThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;MainThread&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.MainThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;BackgroundThread&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.BackgroundThread;</div><div class="line">                    &#125; else if (modifierString.equals(&quot;Async&quot;)) &#123;</div><div class="line">                        threadMode = ThreadMode.Async;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        if (skipMethodVerificationForClasses.containsKey(clazz)) &#123;</div><div class="line">                            continue;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            throw new EventBusException(&quot;Illegal onEvent method, check for typos: &quot; + method);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div></pre></td></tr></table></figure>
<p>上面代码可以看出，默认方法运行在post事件的线程中，同时我们可以自己指定。<br>找到所有的订阅方法，封装在SubscriberMethod实体中并最终返回。</p>
<h3 id="subscribe-订阅过程"><a href="#subscribe-订阅过程" class="headerlink" title="subscribe 订阅过程"></a>subscribe 订阅过程</h3><p>第一阶段找到所有方法后，第二阶段先执行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">    subscribe(subscriber, subscriberMethod, sticky, priority);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>subscribe方法主要包含以下过程：</p>
<ul>
<li>根据EventType找到订阅该事件的订阅队列</li>
<li>找到subsciber订阅的全部事件，并将当前事件添加进去。</li>
<li>处理stick类型的event。</li>
</ul>
<h4 id="subscriptionsByEventType"><a href="#subscriptionsByEventType" class="headerlink" title="subscriptionsByEventType"></a>subscriptionsByEventType</h4><p>EventBus 是一个单例的总线，这个Type就是一个表，使用EventBus时候在onEvent中参数可能是我们自己定义的Event，subscriptionsByEventType中的键就是event的Class对象，值就是该事件对应的订阅队列，当一个event被post消费的时候，从队列中依次选择合适的subscription来处理事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority);</div><div class="line">        if (subscriptions == null) &#123;</div><div class="line">            subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>上面的代码就获得了某个event对应的订阅队列。<br>然后根据优先级将subscription插入合适的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">    if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123;</div><div class="line">        subscriptions.add(i, newSubscription);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="typesBySubscriber"><a href="#typesBySubscriber" class="headerlink" title="typesBySubscriber"></a>typesBySubscriber</h4><p>同样是一个表结构，键是 subscriber，值是该subscriber订阅的eventType列表。第二步就是维护这个表的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">if (subscribedEvents == null) &#123;</div><div class="line">    subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;();</div><div class="line">    typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">&#125;</div><div class="line">subscribedEvents.add(eventType);</div></pre></td></tr></table></figure>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p>第三步对之前post的stick事件进行处理，如果发现当前subscriber订阅了一个stick事件，那么再将该事件重新post一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">synchronized (stickyEvents) &#123;</div><div class="line">    stickyEvent = stickyEvents.get(eventType);</div><div class="line">&#125;</div><div class="line">if (stickyEvent != null) &#123;</div><div class="line">     postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="post过程"><a href="#post过程" class="headerlink" title="post过程"></a>post过程</h2><h3 id="currentPostingThreadState"><a href="#currentPostingThreadState" class="headerlink" title="currentPostingThreadState"></a>currentPostingThreadState</h3><p>虽然EventBus是一个单例总线，但是设计了一个ThreadLocal变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    protected PostingThreadState initialValue() &#123;</div><div class="line">        return new PostingThreadState();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，不同的线程在调用EventBus的post方法时，其实都是读取其线程封闭的变量PostingThreadState。在PostThreadState中，封装了当前线程eventQueue和post信息的状态isPosting。这里可以看到，eventBus的post方法实际上是会产生阻塞的，当生产者生产消息过快而消费者消费消息过慢的时候，会带来消息的积压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (!eventQueue.isEmpty()) &#123;</div><div class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</div><div class="line">                &#125;</div></pre></td></tr></table></figure>
<h3 id="postSingleEvent"><a href="#postSingleEvent" class="headerlink" title="postSingleEvent"></a>postSingleEvent</h3><p>流程：</p>
<ul>
<li>将EventType的Class对象、以及接口、父类Class对象全部加入缓存。表eventTypesCache键是event的Class对象，值是该event相关的接口、父类以及本身的Class对象。</li>
<li>寻找该事件的订阅者，并将事件交给订阅的subscription进行处理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">synchronized (this) &#123;</div><div class="line">                subscriptions = subscriptionsByEventType.get(clazz);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>subscriptionsByEventType表前面介绍过，这里可以看到EventBus在注册订阅者和发布事件的时候是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">for (Subscription subscription : subscriptions) &#123;</div><div class="line">    postingState.event = event;</div><div class="line">    postingState.subscription = subscription;</div><div class="line">    boolean aborted = false;</div><div class="line">    try &#123;</div><div class="line">        postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">        aborted = postingState.canceled;</div><div class="line">    &#125; finally &#123;</div><div class="line">        postingState.event = null;</div><div class="line">        postingState.subscription = null;</div><div class="line">        postingState.canceled = false;</div><div class="line">    &#125;</div><div class="line">    if (aborted) &#123;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>寻找subscription，对当前线程post状态PostingThreadState状态更新。这里再次可以看到，如果postToSubscription方法是阻塞的，那么eventBus也存在阻塞的可能。</p>
<ul>
<li><p>第三个阶段比较简单，如果没有找到任何订阅，那么新发送一条没找到订阅的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!subscriptionFound) &#123;</div><div class="line">    Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);</div><div class="line">    if (eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">        post(new NoSubscriberEvent(this, event));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>
<h3 id="postToSubscription"><a href="#postToSubscription" class="headerlink" title="postToSubscription"></a>postToSubscription</h3><p>EventBus是基于发布订阅模型的，上面提到，在总线Bus中注册了订阅Subscription之后，接下来在post发布事件时候会去寻找相应的Subscription处理事件。post核心发布代码十分简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</div><div class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">    case PostThread:</div><div class="line">        invokeSubscriber(subscription, event);</div><div class="line">        break;</div><div class="line">    case MainThread:</div><div class="line">        if (isMainThread) &#123;</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">        &#125; else &#123;</div><div class="line">            mainThreadPoster.enqueue(subscription, event);</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    case BackgroundThread:</div><div class="line">        if (isMainThread) &#123;</div><div class="line">            backgroundPoster.enqueue(subscription, event);</div><div class="line">        &#125; else &#123;</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    case Async:</div><div class="line">        asyncPoster.enqueue(subscription, event);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，找出当前订阅方法的执行线程，如果是post的线程直接执行，如果是UI线程判断当前线程并进行相应处理。总的来说分为两种情况：</p>
<ul>
<li>直接invokeSubscriber</li>
<li>将subscription和event给到指定的Poster中</li>
</ul>
<h4 id="invokeSubscriber"><a href="#invokeSubscriber" class="headerlink" title="invokeSubscriber"></a>invokeSubscriber</h4><p>方法中首先直接反射调用注册该事件的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div></pre></td></tr></table></figure>
<p>从发布到订阅，就这么简单粗暴的完成了。</p>
<h4 id="Poster"><a href="#Poster" class="headerlink" title="Poster"></a>Poster</h4><p>EventBus支持订阅方法执行在不同的线程中，主要通过Poster来实现的。</p>
<ul>
<li><p>HandlerPoster</p>
<p>如果要让一个方法执行在MainThread中，最简单的方式就是通过Handler。HandlerPoster继承Handler，enqueue方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</div><div class="line">synchronized (this) &#123;</div><div class="line">    queue.enqueue(pendingPost);</div><div class="line">    if (!handlerActive) &#123;</div><div class="line">        handlerActive = true;</div><div class="line">        if (!sendMessage(obtainMessage())) &#123;</div><div class="line">            throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>PendingPost封装了要在UI线程中执行的subscription和event，PendingPostQueue存储pendingPost，因为要执行在UI线程中的onEvent可能受线程并发方法造成影响，所以添加了内置锁。接下来就是利用Handler发送一条Message，通过handler的handleMessage重载方法，我们就获取了在UI线程的执行环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">while (true) &#123;</div><div class="line">    PendingPost pendingPost = queue.poll();</div><div class="line">    if (pendingPost == null) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Check again, this time in synchronized</div><div class="line">            pendingPost = queue.poll();</div><div class="line">            if (pendingPost == null) &#123;</div><div class="line">                handlerActive = false;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eventBus.invokeSubscriber(pendingPost);</div><div class="line">    long timeInMethod = SystemClock.uptimeMillis() - started;</div><div class="line">    if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</div><div class="line">        if (!sendMessage(obtainMessage())) &#123;</div><div class="line">            throw new EventBusException(&quot;Could not send handler message&quot;);</div><div class="line">        &#125;</div><div class="line">        rescheduled = true;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleMessage中流程：</p>
<ul>
<li>从pendingPostQueue中取出待处理的post，调用相应subscription执行</li>
<li>防止在该方法中停留过久对UI线程造成阻塞，对执行时间进行限制。</li>
</ul>
<p>总的来说就是，HandlerPoster中通过一个Queue，将pendingPost 的enqueue和执行操作分离在不同的执行环境中。</p>
<h4 id="BackgroundPoster"><a href="#BackgroundPoster" class="headerlink" title="BackgroundPoster"></a>BackgroundPoster</h4><p>HandlerPoster可以通过Handler实现，BackgroundPoster的实现则是通过Runnable。enqueue的时候除了将pendingPost加入到queue中，还将当前runnable送到executorService中执行。</p>
<p>runnable任务在executor中执行后，会不断从queue中取出pendingPost并执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">while (true) &#123;</div><div class="line">    PendingPost pendingPost = queue.poll(1000);</div><div class="line">    if (pendingPost == null) &#123;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Check again, this time in synchronized</div><div class="line">            pendingPost = queue.poll();</div><div class="line">            if (pendingPost == null) &#123;</div><div class="line">                executorRunning = false;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eventBus.invokeSubscriber(pendingPost);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，EventBus的发布订阅模型分析完成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;EventBus&quot;&gt;&lt;a href=&quot;#EventBus&quot; class=&quot;headerlink&quot; title=&quot;EventBus&quot;&gt;&lt;/a&gt;EventBus&lt;/h2&gt;&lt;p&gt;EventBus本身是一个发布订阅的库，最方便的用处就是消息的回调。指定接收事件的组件，并可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RecyclerView 源码学习及自定义LayoutManager</title>
    <link href="http://mryy.com/2017/03/13/RecyclerView-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/"/>
    <id>http://mryy.com/2017/03/13/RecyclerView-源码学习及自定义LayoutManager/</id>
    <published>2017-03-13T15:49:31.000Z</published>
    <updated>2017-04-19T13:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RecyclerView-的三驾马车"><a href="#RecyclerView-的三驾马车" class="headerlink" title="RecyclerView 的三驾马车"></a>RecyclerView 的三驾马车</h1><h2 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h2><p>掌管RecyclerView的布局，你可以通过它实现一个listview、gridview、瀑布流等效果。LayoutManager主要作用与RecyclerView的measure和layout过程中。LayoutManager是RecyclerView中的一个内部抽象类，具体实现类有GridLayoutManager，LinearLayoutManager，StaggerLayoutManager等。每一个LayoutManager只能和一个RecyclerView绑定，调用setLayoutManager后，当一个LayoutManager被绑定到RecyclerView的时候，会回调LayoutManager的onAttachedToWindow接口。</p>
<h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>视图测绘的过程中，ViewRootImpl会执行perforMeasure方法，然后View的measure方法会被调用，同时注意measure方法是final不可重写，同时在measure中调用了相应View的onMeasure，所以我们只要查看onMeasure即可。我们可以实现LayoutManager中的onMeasure方法完成整个recyclerView的测量，来标定其大小，否则RecyclerView会直接调用其默认measure方法，也就是我们通常设置在LayoutParams中的大小，完成对RececylerView整个大小的measure。当通过adapter向RecyclerView中添加child view后，在进行addView的时候又会根据子View的LayoutParams进行child view的布局。</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>layout则由onLayout中实现，调用 dispatchLayout() ，其中调用 onLayoutChildren，即可以调用到LayoutManager具体实现的onLayoutChildren。</p>
<p>在RecyclerView 进行 onMeasure的时候，调用了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (mLayout == null) &#123;</div><div class="line">    defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">&#125; else &#123;</div><div class="line">    mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们设置了LayoutManager，那么则由LayoutManager的onMeasure来完成测绘。然后去看实现类，以LinearLayoutManager为例，我们会发现其中并没有onMeasure的实现，这是因为</p>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><p>LayoutManager负责布局，而adapter就是负责数据，以及每一个child view的提供。</p>
<h3 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h3><p>adapter中getCount，getItem等方法有点类似ListView，ViewHolder有点类似ListView中我们自定义用来回收利用convertView 的holder。只不过这里进一步的封装，并有recyclerview去调度管理。</p>
<p>ViewHolder构造代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public ViewHolder(View itemView) &#123;</div><div class="line">    if (itemView == null) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;itemView may not be null&quot;);</div><div class="line">    &#125;</div><div class="line">    this.itemView = itemView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中将我们定义的View绑定在了ViewHolder中。通过自定义adapter，主要重写的方法是onCreateViewHolder和onBindViewHolder。我们的onCreateViewHolder会在Adapter中的 createViewHolder调用，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    public final VH createViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);</div><div class="line">        final VH holder = onCreateViewHolder(parent, viewType);</div><div class="line">        holder.mItemViewType = viewType;</div><div class="line">        TraceCompat.endSection();</div><div class="line">        return holder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而createViewHolder又会在getViewForPosition方法中被调用，其中会经历检查无用的ViewHolder，可以回收的ViewHolder一系列过程，最后如果没有会调用adapter的createViewHolder，在其中还会调用bindViewHolder，也就是我们实现的方法完成视图和数组的绑定。</p>
<h4 id="ViewHolder中的ItemView"><a href="#ViewHolder中的ItemView" class="headerlink" title="ViewHolder中的ItemView"></a>ViewHolder中的ItemView</h4><h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h2><p>ItemDecoration负责每一个ItemView的padding修整，背景以及蒙层绘制。</p>
<p>在说明ItemDecoration之前首先要看一下view中draw事件的传递：</p>
<p>View的绘制过程通过dispatchView实现，会调用所有子view的draw方法，draw事件被一层一层传递下去。在View的默认实现draw中，遵循以下流程：</p>
<ol>
<li>绘制背景 drawBackground</li>
<li>绘制视图内容，即调用自身的 onDraw</li>
<li>绘制child view</li>
</ol>
<p>使用ItemDecoration，主要通过覆写以下方法：</p>
<h3 id="getItemOffsets"><a href="#getItemOffsets" class="headerlink" title="getItemOffsets"></a>getItemOffsets</h3><p>可以通过对outRect.set的设置，设置list中每个item的padding值。在RecyclerView 对子view，也就是每个item进行测绘的时候，measureChild中有以下代码：</p>
<h3 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h3><p>RecyclerView 被父布局调用draw方法，draw方法中关键代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas c) &#123;</div><div class="line">    super.draw(c);</div><div class="line">    final int count = mItemDecorations.size();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mItemDecorations.get(i).onDrawOver(c, this, mState);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中super.draw 调用了view的默认实现，那么会调用自身的onDraw方法，Recyclerview的onDraw中有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void onDraw(Canvas c) &#123;</div><div class="line">    super.onDraw(c);</div><div class="line">    final int count = mItemDecorations.size();</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        mItemDecorations.get(i).onDraw(c, this, mState);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，recyclerview进行绘制的时候，首先绘制背景，然后调用了ItemDecoration 的onDraw方法，之后对child进行绘制，然后最后调用了onDrawOver方法。因为Canvas是每一层都绘制在原始的层面之上的，所以我们可以认为ItemDecoration中，onDraw是绘制每个item的背景，onDrawOver是最后再在最上面绘制一层。所以我们可以利用这两个方法绘制背景或者绘制蒙层。而getViewForPosition这个方法，则是由LayoutManager在onLayoutChildren布局的时候，最终调用到的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">View next(RecyclerView.Recycler recycler) &#123;</div><div class="line">    if (mScrapList != null) &#123;</div><div class="line">        return nextViewFromScrapList();</div><div class="line">    &#125;</div><div class="line">    final View view = recycler.getViewForPosition(mCurrentPosition);</div><div class="line">    mCurrentPosition += mItemDirection;</div><div class="line">    return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#### </p>
<p>measureChild 时候有 getItemDecorInsetsForChild，其中调用了getItemOffsets，然后依据此计算了 child 中外层layout的params，实现child的测绘，</p>
<hr>
<p>上半部分介绍了RecyclerView的整体结构，接下来聚焦在LayoutManager部分，来自定义一个简单的LayoutManager。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h2><p>LayoutManager调用 getViewForPosition 获取一个item，Recycler会决定是从缓存返回还是生成新的item。在自定义LayoutManger的时候，要保证不可见的视图被传递给Recycler。</p>
<h2 id="Scrap-或-Recycler"><a href="#Scrap-或-Recycler" class="headerlink" title="Scrap 或 Recycler"></a>Scrap 或 Recycler</h2><p>Recycler是二级缓存，一个scrap heap 和一个 recyle pool， scrap 中的数据是正确的数据，比如我们快速上下滑动列表时，在边缘的栏目一会显示一会消失，所以会放在scrap中。 而已经消失并不使用的item，会被放在recyle中，其中的数据也是不正确的。</p>
<p>每次LayoutManager去请求一个视图调用getViewForPosition的时候，会先从scrap heap中找，存在直接返回。否则去recyle pool 中找一个视图，然后重新在adapter中绑定数据。最终如果还没有缓存，调用我们在adapter中重写的onCreateViewHolder，生成一个新的ViewHolder绑定数据并返回。</p>
<p>使用 detachAndScrapView 将视图放进scrap中去，使用removeAndRecycleView 将可能不会再用的视图放回recycler并且后续如果使用，还要进行rebind</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实，上面这些都是废话，只要知道要获得一个view和用完一个view，都要通过recycler。常用的方法有getViewForPosition ，detachAndScrapView 和 removeAndRecycleView</p>
<h1 id="自定义LayoutManager"><a href="#自定义LayoutManager" class="headerlink" title="自定义LayoutManager"></a>自定义LayoutManager</h1><h3 id="generateDefaultLayoutParams"><a href="#generateDefaultLayoutParams" class="headerlink" title="generateDefaultLayoutParams"></a>generateDefaultLayoutParams</h3><p>作用：控制每个item的layoutParams<br>为每一个childView设置的LayoutParams在这个方法中返回。很简单，一般我们都直接返回一个WrapContent的lp</p>
<h3 id="初始布局-onLayoutChildren"><a href="#初始布局-onLayoutChildren" class="headerlink" title="初始布局 onLayoutChildren"></a>初始布局 onLayoutChildren</h3><p>这个方法会在一个view 第一次执行layout的时候调用，同时也会在adaper的数据集改变并通知观察者（也就是view）的时候调用。所以在其中每一次布局的时候，要先将之前放置的无用的View放回recycler中，因为这些View我们在后续还可能使用，为了减少初始化以及bind的时间，我们调用detachAndScrapAttachedViews。此外，对于不会再用到的View，可以调用removeAndRecycleView进行回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (getItemCount() == 0) &#123;</div><div class="line">    offset = 0;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里自定义的LayoutManager比较简单，假定全部的item都是相同的大小。所以可以在一开始进行测绘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (getChildCount() == 0) &#123;</div><div class="line">    View scrap = recycler.getViewForPosition(0);</div><div class="line">    addView(scrap);</div><div class="line">    measureChildWithMargins(scrap, 0, 0);</div><div class="line">    mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);</div><div class="line">    mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);</div><div class="line">    startLeft = (getHorizontalSpace() - mDecoratedChildWidth) / 2;</div><div class="line">    startTop = (getVerticalSpace() - mDecoratedChildHeight) / 2;</div><div class="line">    interval = 10;</div><div class="line">    detachAndScrapView(scrap, recycler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意getItemCount和getChildCount的区别：前者是adapter中添加的数据的数目，而后者是当前recyclerView中已经添加的子View的数目。所以上述代码的含义就是，如果没有添加过子View，那么从recycler中取出一个并完成测绘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">recycler.getViewForPosition(0);</div><div class="line">            addView(scrap);</div></pre></td></tr></table></figure>
<p>测绘完成后，再重新放回recycler中，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detachAndScrapView(scrap, recycler);</div></pre></td></tr></table></figure>
<p>最后，再将之前添加的全部子View放回recycler中，因为一会还要使用，为了避免rebind，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">detachAndScrapAttachedViews(recycler);</div></pre></td></tr></table></figure>
<p>然后就可以进行layoutChildren的过程了。</p>
<p>先来一个简单的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int left = 100, top = 0;</div><div class="line">        for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">            if (outOfRange(top)) continue;</div><div class="line">            View scrap = recycler.getViewForPosition(i);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            addView(scrap);</div><div class="line">            layoutDecorated(scrap, left, top, left + mDecoratedChildWidth, top + mDecoratedChildHeight);</div><div class="line">            top += mDecoratedChildHeight + interval;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>基本效果就是这样：<br><img src="http://img.blog.csdn.net/20170313154744954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="处理滑动-canScroll-和-scrollXXXBy"><a href="#处理滑动-canScroll-和-scrollXXXBy" class="headerlink" title="处理滑动 canScroll 和 scrollXXXBy"></a>处理滑动 canScroll 和 scrollXXXBy</h3><p>基本的布局有了之后，就可以处理滑动了。<br>RecyclerView是一个ViewGroup，如果要处理滑动事件，必然要进行拦截，分析其中的onInterceptTouchEvent方法：</p>
<p>关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line"> final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"> ...</div><div class="line"> case MotionEvent.ACTION_MOVE:</div><div class="line"> ...</div><div class="line"> if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                 mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1);</div><div class="line">                 startScroll = true;</div><div class="line">             &#125;</div><div class="line">if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                 mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1);</div><div class="line">                 startScroll = true;</div><div class="line">             &#125;</div><div class="line">             ...</div><div class="line">if (startScroll) &#123;                      setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">             &#125;</div><div class="line">             ...</div><div class="line">return mScrollState == SCROLL_STATE_DRAGGING;</div></pre></td></tr></table></figure>
<p>这里可以知道，如果要拦截某个方向的滑动事件，那么要在mLayout也就是LayoutManager中重写相应的canScrollxxx方法。<br>比如我们要允许竖直方向的滑动，直接重写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean canScrollVertically() &#123;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下事件拦截以后，在onTouchEvent中怎么处理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (scrollByInternal(</div><div class="line">                    canScrollHorizontally ? dx : 0,</div><div class="line">                        canScrollVertically ? dy : 0,</div><div class="line">                            vtev)) &#123;</div><div class="line">getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">                    &#125;</div></pre></td></tr></table></figure>
<p>代码很多，关键在于在ACTION_MOVE事件中调用了scrollByInternal方法，其中又有如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (x != 0) &#123;</div><div class="line">    consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</div><div class="line">    unconsumedX = x - consumedX;</div><div class="line">&#125;</div><div class="line">if (y != 0) &#123;</div><div class="line">    consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</div><div class="line">    unconsumedY = y - consumedY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是调用了LayoutManager中自定义的scrollxxxBy方法，并且传入Recycler供我们获取和回收View，以及相应的坐标x和y。</p>
<p>除此之外，要注意这个scrollxxxBy方法还有个返回值，这个返回值就是我们当前处理了的滑动坐标。如果这个值小于传入的坐标，表明我们已经滑动到了尽头，这么说可能有点抽象，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">     return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>返回0的时候，无论怎样都会小于传入的dy，看一下效果：</p>
<p><img src="http://img.blog.csdn.net/20170313161058596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到，我向下和向上滑动的时候，上边沿和下边沿都会出现一个动画效果，表明已经到头了！就是由于返回值是0的缘故。</p>
<p>分析到这里，基本可以确定如何添加滚动效果了，关键在两点：</p>
<ol>
<li>canScrollXXX中返回true</li>
<li>在onTouchEvent中scrollXXXBy方法不断被调用，在其中完成LayoutChildren不断对子View进行放置，从而形成动画效果。</li>
</ol>
<p>为了完成第二个目的，我们需要在代码中添加一些额外的属性，主要就是每个item的偏移量，这样，在获得dy的时候，可以在每个item原有偏移量的基础上进行移动以及回收不需要的view。</p>
<p>首先，用一个全局变量 List<float> offsetList 来存储每一个item的偏移量，并在onLayoutChildren中进行初始化：</float></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; getItemCount(); i++) &#123;</div><div class="line">    offsetList.add(property);</div><div class="line">    property += mDecoratedChildHeight + interval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>滑动方面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">    int willScroll = dy;</div><div class="line">    offset += willScroll;</div><div class="line">    layoutItems(recycler, state, dy);</div><div class="line">    return willScroll;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且，原先对item的layout的过程也要进行一些修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">    for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View view = getChildAt(i);</div><div class="line">        int pos = getPosition(view);</div><div class="line">        if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">            removeAndRecycleView(view, recycler);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    int left = 100;</div><div class="line">    for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">        int top = offsetList.get(i);</div><div class="line">        if (outOfRange(top - offset)) continue;</div><div class="line">        View scrap = recycler.getViewForPosition(i);</div><div class="line">        measureChildWithMargins(scrap, 0, 0);</div><div class="line">        if (dy &gt;= 0)</div><div class="line">            addView(scrap);</div><div class="line">        else</div><div class="line">            addView(scrap, 0);</div><div class="line">        layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20170313171417783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上述代码中，对每一个item记录了一下它的位置，然后滑动过程中offset+=dy，并且每次滑动后都出发LayoutItems方法，并且每个item在初始化y值的基础上减去offset，得到新的布局的位置。<br>到此为止，就有了滑动的动画效果：</p>
<p><img src="http://img.blog.csdn.net/20170313172759587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="缩放效果"><a href="#缩放效果" class="headerlink" title="缩放效果"></a>缩放效果</h3><p>经常有这样一种需求，当滑动列表的时候，列表中间部分某些item会呈现出放大之类的动画效果。其实，这种效果的实现其实就是通过item的属性动画。</p>
<p>实现的思路也比较简单，定一条基准线middle如下：</p>
<p><img src="http://img.blog.csdn.net/20170313175823822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在每一个进行layout的时候计算每一个item的坐标，距离middle中线最近的那个我们给它放大，就实现了一个类似选中当前重点的效果。当然，具体的动画效果我们可以自己去计算选择。</p>
<p>新的layoutItems代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">    for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">        View view = getChildAt(i);</div><div class="line">        int pos = getPosition(view);</div><div class="line">        if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">            removeAndRecycleView(view, recycler);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    detachAndScrapAttachedViews(recycler);</div><div class="line">    int left = 100;</div><div class="line">    View selectedView = null;</div><div class="line">    float maxScale = Float.MIN_VALUE;</div><div class="line">    for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">        int top = offsetList.get(i);</div><div class="line">        if (outOfRange(top - offset)) continue;</div><div class="line">        View scrap = recycler.getViewForPosition(i);</div><div class="line">        measureChildWithMargins(scrap, 0, 0);</div><div class="line">        if (dy &gt;= 0)</div><div class="line">            addView(scrap);</div><div class="line">        else</div><div class="line">            addView(scrap, 0);</div><div class="line"></div><div class="line">        int deltaY = Math.abs(top - offset - middle);</div><div class="line">        scrap.setScaleX(1);</div><div class="line">        scrap.setScaleY(1);</div><div class="line">        float scale = 1 + (mDecoratedChildHeight / (deltaY + 1));</div><div class="line">        if (scale &gt; maxScale) &#123;</div><div class="line">            maxScale = scale;</div><div class="line">            selectedView = scrap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (selectedView != null) &#123;</div><div class="line">        maxScale = maxScale &gt; 2 ? 2 : maxScale;</div><div class="line">        selectedView.setScaleX(maxScale);</div><div class="line">        selectedView.setScaleY(maxScale);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后可以得到下面这样一个比较粗糙的效果：</p>
<p><img src="http://img.blog.csdn.net/20170313180136946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最后，来贴一下完整的代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">package rouchuan.circlelayoutmanager;</div><div class="line"></div><div class="line">import android.content.Context;</div><div class="line">import android.support.v7.widget.RecyclerView;</div><div class="line">import android.view.View;</div><div class="line">import android.view.ViewGroup;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by yangyang on 2017/3/13.</div><div class="line"> */</div><div class="line"></div><div class="line">public class SimpleLayoutManager extends RecyclerView.LayoutManager &#123;</div><div class="line">    private int mDecoratedChildWidth;</div><div class="line">    private int mDecoratedChildHeight;</div><div class="line">    private int interval;</div><div class="line">    private int middle;</div><div class="line">    private int offset;</div><div class="line">    private List&lt;Integer&gt; offsetList;</div><div class="line">    public SimpleLayoutManager(Context context) &#123;</div><div class="line">        offsetList = new ArrayList&lt;&gt;();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public RecyclerView.LayoutParams generateDefaultLayoutParams() &#123;</div><div class="line">        return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        if (getItemCount() == 0) &#123;</div><div class="line">            offset = 0;</div><div class="line">            detachAndScrapAttachedViews(recycler);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //初始化的过程，还没有childView，先取出一个测绘。 认为每个item的大小是一样的</div><div class="line">        if (getChildCount() == 0) &#123;</div><div class="line">            View scrap = recycler.getViewForPosition(0);</div><div class="line">            addView(scrap);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);</div><div class="line">            mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);</div><div class="line">            interval = 10;</div><div class="line">            middle = (getVerticalSpace() - mDecoratedChildHeight) / 2;</div><div class="line">            detachAndScrapView(scrap, recycler);</div><div class="line">        &#125;</div><div class="line">        //回收全部attach 的 view 到 recycler 并重新排列</div><div class="line">        int property = 0;</div><div class="line">        for (int i = 0; i &lt; getItemCount(); i++) &#123;</div><div class="line">            offsetList.add(property);</div><div class="line">            property += mDecoratedChildHeight + interval;</div><div class="line">        &#125;</div><div class="line">        detachAndScrapAttachedViews(recycler);</div><div class="line">        layoutItems(recycler, state, 0);</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean canScrollVertically() &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        int willScroll = dy;</div><div class="line">        offset += willScroll;</div><div class="line">        if (offset &lt; 0 || offset &gt; offsetList.get(offsetList.size() - 1)) return 0;</div><div class="line">        layoutItems(recycler, state, dy);</div><div class="line">        return willScroll;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    private void layoutItems(RecyclerView.Recycler recycler, RecyclerView.State state, int dy) &#123;</div><div class="line">        for (int i = 0; i &lt; getChildCount(); i++) &#123;</div><div class="line">            View view = getChildAt(i);</div><div class="line">            int pos = getPosition(view);</div><div class="line">            if (outOfRange(offsetList.get(pos) - offset)) &#123;</div><div class="line">                removeAndRecycleView(view, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        detachAndScrapAttachedViews(recycler);</div><div class="line">        int left = 100;</div><div class="line">        View selectedView = null;</div><div class="line">        float maxScale = Float.MIN_VALUE;</div><div class="line">        for (int i = 0; i&lt; getItemCount(); i++) &#123;</div><div class="line">            int top = offsetList.get(i);</div><div class="line">            if (outOfRange(top - offset)) continue;</div><div class="line">            View scrap = recycler.getViewForPosition(i);</div><div class="line">            measureChildWithMargins(scrap, 0, 0);</div><div class="line">            if (dy &gt;= 0)</div><div class="line">                addView(scrap);</div><div class="line">            else</div><div class="line">                addView(scrap, 0);</div><div class="line"></div><div class="line">            int deltaY = Math.abs(top - offset - middle);</div><div class="line">            scrap.setScaleX(1);</div><div class="line">            scrap.setScaleY(1);</div><div class="line">            float scale = 1 + (mDecoratedChildHeight / (deltaY + 1));</div><div class="line">            if (scale &gt; maxScale) &#123;</div><div class="line">                maxScale = scale;</div><div class="line">                selectedView = scrap;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            layoutDecorated(scrap, left, top - offset, left + mDecoratedChildWidth, top - offset + mDecoratedChildHeight);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (selectedView != null) &#123;</div><div class="line">            maxScale = maxScale &gt; 2 ? 2 : maxScale;</div><div class="line">            selectedView.setScaleX(maxScale);</div><div class="line">            selectedView.setScaleY(maxScale);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private boolean outOfRange(float targetOffSet) &#123;</div><div class="line">        return targetOffSet &gt; getVerticalSpace() + mDecoratedChildHeight ||</div><div class="line">                targetOffSet &lt; -mDecoratedChildHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getHorizontalSpace() &#123;</div><div class="line">        return getWidth() - getPaddingLeft() - getPaddingRight();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private int getVerticalSpace() &#123;</div><div class="line">        return getHeight() - getPaddingTop() - getPaddingBottom();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RecyclerView-的三驾马车&quot;&gt;&lt;a href=&quot;#RecyclerView-的三驾马车&quot; class=&quot;headerlink&quot; title=&quot;RecyclerView 的三驾马车&quot;&gt;&lt;/a&gt;RecyclerView 的三驾马车&lt;/h1&gt;&lt;h2 id=&quot;L
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存泄漏分析实战</title>
    <link href="http://mryy.com/2016/12/21/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    <id>http://mryy.com/2016/12/21/Android内存泄漏分析实战/</id>
    <published>2016-12-21T12:52:34.000Z</published>
    <updated>2017-04-19T14:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。<br>本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。<br>撰写过程中，本人深感JVM、操作系统相关知识了解不够深刻，不足之处非常欢迎指正说明。</p>
<p>#<strong>内存泄漏基本概念</strong></p>
<p>内存检测这部分，相关的知识有JVM虚拟机垃圾收集机制，类加载机制，内存模型，以及操作系统的基础知识（所以不要说JVM有啥用，操作系统有啥用啦 :) ）。<br>编写没有内存泄漏的程序，对提高程序稳定性，提高用户体验具有重要的意义；同时，也是java程序员进阶的重要内容。利用java编写程序的时候，要特别注意内存泄漏相关的问题。虽然JVM提供了自动垃圾回收机制，但是还是有很多情况会导致内存泄漏。<br>内存泄漏主要原因就是一个生命周期长的对象，持有了一个生命周期短的对象的引用。这样，会导致短的对象在该回收时候无法被回收。Android中比较典型的有：<br>1、静态变量持有Activity的context。<br>2、或者Handler持有某个组件的context，同时如果Looper的消息队列中有针对该Handler的消息没有被处理，那么会被作为target持有强引用，最终的导致context无法释放，导致相应组件在退出时无法被内存回收。<br>3、非静态内部类默认持有外部类的引用。有时候为了方便，我们会在Activity中定义一个Thread内部类，同时直接通过new Thread的方式去运行线程，那么在线程运行结束之前，线程都会持有Activity的引用，从而导致Activity无法被释放。</p>
<hr>
<p>#<strong>内存检测工具</strong></p>
<p>##LeakCananry</p>
<p>###使用步骤</p>
<p>LeakCanary，主要监测的是使用过程中Activity，Fragment等组件是否没被内存回收。使用方法也十分简单，相当于装了一个监听器，然后通过正常 操作去寻找内存泄漏，发生内存泄漏的时候会有Toast，同时可以在相应程序查看哪里发生内存泄漏。<br>方法比较简单，具体步骤可以查阅官方github。添加leakcanary依赖以后，新建一个Application入口，在Oncreate方法中安装Leakcanary即可。<br><img src="http://img.blog.csdn.net/20161221161742393?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>当发生内存泄漏时，屏幕会出现Toast，同时打开桌面上的Leaks程序，显示泄漏的内存，如下图：<br><img src="http://img.blog.csdn.net/20161221161848567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>###整体流程<br>LeakCananry实现步骤大致是：<br>实现大致步骤是：<br>1、自动把activity加入到KeyedWeakReference<br>2、在background线程中，检查onDestroy后reference是否被清除，且没有触发gc<br>3、如果reference没有被清除，则dump heap到一个hprof文件并保存到app文件系统中<br>4、在一个单独进程中启动HeapAnalyzerService，HeapAnalyzer使用HAHA来分析heap dump。<br>5、HeapAnalyzer在heap dump中根据reference key找到KeyedWeakReference。<br>6、HeapAnalyzer计算出到GC Roots的最短强引用路径来判断是否存在泄露，然后build出造成这个泄露的引用链。<br>7、结果被传回来app进程的DisplayLeakService，并展示一个泄露的notification。</p>
<p>###结论<br><strong>方法的优点是简单易行，但是只能检测Activity、Fragment是否发生内存泄漏。</strong> 对于一些项目比如sdk开发，很可能整个程序没有一个Activity，所以这种方式就不是很实用。</p>
<hr>
<p>##观看整体内存使用情况<br>详情参见官方文档：<br><a href="https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations" target="_blank" rel="external">https://developer.android.com/studio/profile/investigate-ram.html#ViewingAllocations</a><br>使用adb shell，进入手机adb，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dumpsys meminfo &lt;包名&gt; [-参数]</div></pre></td></tr></table></figure>
<p>可以查看应用不同部分内存分配情况。比如Java heap，Native heap等<br>输出是目前具体应用的内存分配，单位是kilobytes<br>因为程序涉及jni，经常会分配本地内存，所以会使用adb shell 的方式去查看native heap的分配情况。</p>
<p>结果如下：</p>
<p><img src="http://img.blog.csdn.net/20161221170039609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>分析各个参数：<br>Private Clean/Dirty RAM：<br>这部分内存是app的私有内存，当app销毁是操作系统可以回收到全部的内存。其中private dirty只能被你的进程使用，同时只能存在在内存当中，当内存不够，也不能通过分页技术存储到硬盘（操作系统相关知识），dalvik和native heap上的分配都是private dirty RAM。 Dirty RAM是内存中被修改过的页面，而Clean RAM是从持久文件（比如代码执行文件）映射出的内存。</p>
<p>PSS Total:<br>我们知道，进程之间彼此通信底层通过Binder Driver，通过操控一块共享内存进行读写来相互通信。这样一来，为了进程间通信，Binder会为每个进程在共享内存中开辟一块空间。<br>PSS的部分，包含了每个进程的共享内存。例如，一个内存页面被两个进程共享，那么页面大小的一半会被加到两个进程各自的PSS中。<br>通过累加全部进程的PSS，我们可以查看整个系统的内存使用情况。事实上，PSS是衡量 （实际）使用内存的重要标准。</p>
<p>Dalvik Heap：<br>该字段衡量的是Dalvik虚拟机上堆分配情况，也就是我们在Java中使用new生命对象分配的内存。<br>列中PSS Total包括了和其它Zygote进程共享的内存（全部app进程都是从Zygote中fork出来的，都有一部分内存共享）。而Private Dirty则是app进程本身所使用的的内存。</p>
<p>.so mmap / .dex mmap<br>这部分主要指的是本地代码（so）和Davlik 虚拟机代码（dex）的代码大小。PSS Total列中指的是包含android平台的代码，而private clean仅仅是程序本身运行的代码。</p>
<p>上面参数很多，理解相关知识需要掌握操作系统内存部分。我们在测试的使用，一般情况下，我们关注private Dirty或者pss Total就可以查看app内存整体趋势。</p>
<hr>
<p>##DDMS</p>
<p>####使用流程</p>
<ol>
<li>启动eclipse后，切换到DDMS透视图，并确认Devices视图、Heap视图都是打开的；</li>
<li>将手机通过USB链接至电脑，链接时需要确认手机是处于“USB调试”模式，而不是作为“MassStorage”；</li>
<li>链接成功后，在DDMS的Devices视图中将会显示手机设备的序列号，以及设备中正在运行的部分进程信息；</li>
<li>点击选中想要监测的进程，比如system_process进程；</li>
<li>点击选中Devices视图界面中最上方一排图标中的“Update Heap”图标；</li>
<li>点击Heap视图中的“Cause GC”按钮；</li>
<li>此时在Heap视图中就会看到当前选中的进程的内存使用量的详细情况。</li>
</ol>
<p>####如何检测内存泄漏？<br>Heap视图中部有一个Type叫做dataobject，即数据对象，也就是我们的程序中实例化的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。<br>正常情况下Total Size值都会稳定在一个有限的范围内，也就是说没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平。如果代码中存在没有释放对象引用的情况，则dataobject的Total Size值在每次GC后不会有明显的回落，随着操作次数的增多Total Size的值会越来越大</p>
<p>通过DDMS方式，DataObject 的totalSize如果稳定在一个大概范围内，则可以确定没有发生内存泄漏。</p>
<hr>
<p>##MAT<br>然而，并不是所有的内存泄漏都十分明显，并且会最终导致OOM。有时候只有几个对象被泄漏，虽然影响不大，但是无疑浪费了内存。<br>要发现这种比较隐蔽的内存泄漏，我们需要使用MAT工具。<br>在了解MAT具体使用之前，要先了解一些相关概念。</p>
<p>####支配树<br>支配树体现了对象实例间的支配关系，在对象引用图中，所有指向对象B的路径都经过对象A，则认为对象A支配对象B。<br><img src="http://img.blog.csdn.net/20161221162517783?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在这张图里，左边是对象引用关系，对于A和B，要抵达这两个点必须经过GC root。而对于C可以从A也可以从B抵达，但都必须经过GC root，所以最近的支配点同样也是GC root。<br>对于点D，不管是从C-&gt;D还是C-&gt;D-&gt;F-&gt;D，都必须经过的最近的点是C，所以C是D的支配点。同理可得EFHG在支配树中的位置。</p>
<p>####SHALLOWHEAP和RETAINED HEAP<br>Shallow heap表示对象本身所占内存大小，一个内存大小100bytes的对象Shallow heap就是100bytes。<br>Retained heap表示通过回收这一个对象总共能回收的内存，比方说一个100bytes的对象还直接或者间接地持有了另外3个100bytes的对象引用，回收这个对象的时候如果另外3个对象没有其他引用也能被回收掉的时候，Retained heap就是400bytes。<br>在使用mat进行分析时，我们常常接触到的数据就是shallow size和retained size：<br>Shallow Size<br>对象自身占用的内存大小，不包括它引用的对象。<br>针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。<br>针对数组类型的对象，它的大小是数组元素对象的大小总和。<br>Retained Size<br>Retained Size=当前对象大小+当前对象可直接或间接引用到的对象的大小总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)<br>换句话说，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。<br>不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被回收。如下图：<br><img src="http://img.blog.csdn.net/20161221162603846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>A对象的Retained Size=A对象的Shallow Size<br>B对象的Retained Size=B对象的Shallow Size + C对象的Shallow Size<br>因为B对象被释放时，C同时被释放，而D由于被GC roots直接引用所以不会被释放。而Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存。 </p>
<p>以上概念，都是在使用MAT进行内存分析经常使用的。<br>我们在分析内存泄漏的时候，着重会查看retained heap，也就是这个对象没有被释放前，retained heap中的相关内存不会被释放。<br>然后，在分析某个对象为何没被释放的时候，会查看引用关系或者支撑树。因为引用树父子关系可能比较杂乱，而支撑树更加清晰。</p>
<p>在使用MAT分析内存泄漏的过程中，主要流程就是：<br>1、分析retained heap，找一个使很多对象无法被释放的内存。<br>2、正常情况下，该释放这个对象，所以通过支撑树，或者查看GC 路径，分析为什么这个对象没有被释放。</p>
<p>####MAT的下载与使用<br>下载地址：<a href="https://eclipse.org/mat/downloads.php" target="_blank" rel="external">https://eclipse.org/mat/downloads.php</a><br>这里没有作为eclipse插件的方式下载mat，而是通过下载单独的软件客户端。<br>首先，在DDMS中选择要检测的进程并dump HPROF file，如下图：<br><img src="http://img.blog.csdn.net/20161221162702141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>HPROF中存储的是当前内存的快照，因此，在dump快照之前先点击cause GC手动触发一次垃圾回收，这样可以避免软引用、弱引用等不必要的对象保留在内存中影响我们的分析。</p>
<p>转储出来的hprof文件，还有使用sdk自带工具进行一下格式转化，工具在sdk路径下的platform-tools下，名称为hprof-conv。</p>
<p>使用方法：<br>/.hprof-conv.exe a.hprof b.hprof<br>a 是输入hprof文件名，b是输出文件名。<br>然后将b.hprof在eclipse memory Analyzer中打开，注意要转换格式，不然无法成功打开。<br>如下：</p>
<p><img src="http://img.blog.csdn.net/20161221162902065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>####利用MAT分析内存泄漏<br>分析过程中，主要使用的是Histogram直方图，和Dominater tree支配树。</p>
<p>在Histogram视图中查找retained heap值最大的项，并分析这里是否发生内存泄漏。</p>
<p><img src="http://img.blog.csdn.net/20161221163017644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上图中一坨一坨的，其实就是Class的名称。这样分类比较清晰，后面会说到如何查看Class声明的对象。<br>在最上面class Name下有输入过滤的地方，需要注意是，如果要查看com包下的类，那么要输入com. ，这里的正则中’*’貌似不会去匹配’.’，所以就要我们自己输入啦。 一般情况下，我们忽略会java、android系统自带的类，而着重分析我们自己程序中编写的对象内存使用情况。</p>
<p>Retained heap表示因为这个对象，会导致多少对象无法回收。</p>
<p>右击相应类，list objects-&gt;with incoming references。表明引用这个类的某个实例的其它类，也就是它在引用树中的父节点。通过分析该对象被谁引用，来判断为何没被垃圾回收。<br>outcoming reference就是子节点，查看一些当前对象引用着的对象。</p>
<p>此外看，Merge shortest path to gc root，可以找到一条到GC root的最短路径，来看为什么当前对象无法被回收。</p>
<hr>
<p>##实战分析<br>下面记录了本人对一个项目的具体分析过程，以及各个工具的使用方法。</p>
<p>###<strong>1、使用DDMS查看内存</strong><br>使用DDMS的过程中，针对应用分别进行了多次检测，主要查看程序运行前的内存使用情况和程序运行后的内存使用情况：<br>使用前：</p>
<p><img src="http://img.blog.csdn.net/20161221163735725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>使用后：<br><img src="http://img.blog.csdn.net/20161221163758204?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>通过上述数据可以看到，在程序运行前data object也就是在堆上分配的数据是180KB左右，而运行后内存大概在300KB上下浮动，没有呈现一个明显的一直上升的情况，故而没有明显的内存泄漏，基本没有导致OOM的可能。</p>
<p>但是，可以发现，程序运行一次以后，放置一段时间，即便手动触发GC，堆上的内存虽然回落，但是仍然是288KB，与执行前的180KB相差较大，说明有一些对象被GC roots引用，无法完成释放。</p>
<p>下面采用MAT工具进行进一步分析。在上面的过程中，转出了三个hprof文件，将hprof文件利用Android sdk tools下的工具进行格式转换,进行对比分析：</p>
<p><img src="http://img.blog.csdn.net/20161221163820413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>###<strong>2、使用MAT分析内存转储</strong><br>前面分析内存使用发现，使用前和使用后有一个100KB左右的差值，同时即便放置一段时间仍然无法使用。将before和after的直方图加入对比栏，在MAT中进行对比：<br><img src="http://img.blog.csdn.net/20161221163853538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>点击右上角的红色叹号：</p>
<p><img src="http://img.blog.csdn.net/20161221163913815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161221163927347?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对比发现两个shallow heap大小基本相同，多出的部分是UpdatePartResultThread，系统类而不是我们自己编写程序造成的。<br>再看一下使用前后直方图中的retained heap：</p>
<p><img src="http://img.blog.csdn.net/20161221163953316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看出，程序执行后，newActivity强引用了一些对象，在newAcitivity没有推出前，retainedheap部分内存无法被回收。这也就是我们在DDMS中发现堆内存差异的主要原因。<br>右击直方图中的NewActivity，可以看见如下选项：</p>
<p><img src="http://img.blog.csdn.net/20161221164008175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>用的比较多的是List objects和Merger shortest Paths to GC Roots。<br>List objects：<br>Outgoing reference是支配树中当前对象的子节点，也就是当前对象持有哪些引用。<br>Incoming reference是父节点，即当前对象被谁引用，为什么没被回收。</p>
<p>Merger shortest Paths to GC Roots：找到当前无法被释放的对象到GC roots的最短路径。即排查当前对象被谁引用，为什么没有被释放。这里因为我们的对象是一个Activity，当它显示在前台的时候，不会被垃圾回收，所以不是我们分析的点。</p>
<p>在这里，我们查看outgoing reference，查看当前对象拥有哪些强引用：</p>
<p><img src="http://img.blog.csdn.net/20161221164043992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>排除系统的对象，还是主要分析我们编写的程序。</p>
<p><img src="http://img.blog.csdn.net/20161221164100833?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>最后发现，我们在之前使用LeakCanary时，注册的相应监听器没有回收，发现了内存泄漏 :）。</p>
<p>去掉LeakCanary，再次测试发现data object的值确实下降了不少。</p>
<p>继续分析，发现newActivity引用了一个</p>
<p><img src="http://img.blog.csdn.net/20161221164146461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>致使一部分内存无法被释放。这个问题属于客户端实现问题，不在内存泄漏的范围内。<br>接下来，在直方图中过滤出服务端的类：<br><img src="http://img.blog.csdn.net/20161221164222647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXkyNTQxMTc0NDA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，服务端的类大部分shallow heap都为0，也就是已经被垃圾回收。</p>
<p>##结论<br>在使用MAT分析内存时，最关键的就是找引用关系。如果一个应该被释放的对象没有被释放，那么我们往往要查看它的incoming reference，看看是谁持有了它的强引用。同时利用Merger shortest GC roots找到到GC root的最短路径，确定是由于被谁引用而导致无法GC。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司相关项目需要进行内存优化，所以整理了一些分析内存泄漏的知识以及工作分析过程。&lt;br&gt;本文中不会刻意的编写一个内存泄漏的程序，然后利用工具去分析它。而是通过介绍相关概念，来分析如何寻找内存泄漏，并附上自己的项目实战过程。&lt;br&gt;撰写过程中，本人深感JVM、操作系统相关知识
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态规划简介</title>
    <link href="http://mryy.com/2016/10/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B/"/>
    <id>http://mryy.com/2016/10/29/动态规划简介/</id>
    <published>2016-10-29T13:56:31.000Z</published>
    <updated>2017-04-19T14:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。</p>
<hr>
<p>#解题思路<br>在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新的元素和已有结果是否存在某种关系。<br>对于没有思路的题目，求解可以分为暴力递归（回溯），记忆性搜索，递归优化，时间或空间最终优化四个阶段。<br>在碰到一道可以使用动态规划的题目的时候，如果还不知道怎么下手，那么第一步，一定要去想如何递归求解。<br>所谓递归求解，说的简单点，就是一种穷举，文艺一点，也可以叫回溯。是的，在学习动态规划之前，一定要对回溯法有所了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">backtracking(member)&#123;</div><div class="line">	//如果已经不可能再得到结果，直接返回。也叫剪枝，分支限界。</div><div class="line">	if(is_invalid) return;</div><div class="line">	//如果得到最终结果，处理显示。</div><div class="line">	if(is_solution) print_result();</div><div class="line">	//递归即将进入下一层级，如果有数据在下一层级中需要使用，更新它们。</div><div class="line">	move_ahead();</div><div class="line"></div><div class="line">	//准备要进入递归的元素。</div><div class="line">	candidate[] candidates = get_candidates;</div><div class="line">	for(candidate in candidates)&#123;</div><div class="line">		backtracking(candidate)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//递归回到当前层级，将数据更新回当前层级所需数据。</div><div class="line">	move_back();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是回溯法的基本模板，看清来可能有点模糊，下面的第一道题目的第一个步骤，就将对此作出详细解释。</p>
<p>##题目1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">给一个非负数组，你一开始处在数组收尾（index=0），数组中元素代表你能从当前位置向后跳的**最大**步数，问能否达到数组末尾。比如：</div><div class="line">A = [2,3,1,1,4], return true.</div><div class="line">A = [3,2,1,0,4], return false.</div></pre></td></tr></table></figure>
<p>###递归求解</p>
<p>最为直观的回溯法求解如下：<br>思路十分直观，当我们到了每个位置，在此位置上，可以向后跳1到最大步数，在每一跳之后进行递归，依次类推穷举出所有情况，一旦有一种可以到达最终位置，那么我们就可以得到最终结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</div><div class="line">        if (position == nums.length - 1) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</div><div class="line">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</div><div class="line">            if (canJumpFromPosition(nextPosition, nums)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        return canJumpFromPosition(0, nums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先先进行一下简单的优化，在每一步判断下一跳位置的时候，为了尽快的到达最后的位置，我们很明显应该尽可能多走步数，一旦发现最后无法到达再减少步数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 原始代码</div><div class="line">for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++)</div><div class="line">// 新的代码</div><div class="line">for (int nextPosition = furthestJump; nextPosition &gt; position; nextPosition--)</div></pre></td></tr></table></figure>
<p>###记忆化搜索（自顶向下动态规划）<br>可以看到，上面的递归基本就是暴力解法，那么进一步的优化，就是在递归上面应用存储，已经计算过的分支不再继续进行计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    Index[] memo;</div><div class="line"></div><div class="line">    public boolean canJumpFromPosition(int position, int[] nums) &#123;</div><div class="line">    //存储已经计算过的分支</div><div class="line">        if (memo[position] != Index.UNKNOWN) &#123;</div><div class="line">            return memo[position] == Index.GOOD ? true : false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int furthestJump = Math.min(position + nums[position], nums.length - 1);</div><div class="line">        for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123;</div><div class="line">            if (canJumpFromPosition(nextPosition, nums)) &#123;</div><div class="line">                memo[position] = Index.GOOD;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        memo[position] = Index.BAD;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        memo = new Index[nums.length];</div><div class="line">        for (int i = 0; i &lt; memo.length; i++) &#123;</div><div class="line">            memo[i] = Index.UNKNOWN;</div><div class="line">        &#125;</div><div class="line">        memo[memo.length - 1] = Index.GOOD;</div><div class="line">        return canJumpFromPosition(0, nums);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###去递归（自底向上动态规划）<br>去递归的过程，其实就是人为的分析并指定计算过程的过程。<br>首先分析递归过程中的<strong>可变参数</strong>，这个可变参数就是循环中遍历的变量。这里很明显是当前位置 position。<br>然后需要分析递归的运行顺序，这里可以人为画递归树。我们可以发现，运算实质是从右向左进行的。一个点能否达到某一个点，取决于它右边点的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">enum Index &#123;</div><div class="line">    GOOD, BAD, UNKNOWN</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        Index[] memo = new Index[nums.length];</div><div class="line">        for (int i = 0; i &lt; memo.length; i++) &#123;</div><div class="line">            memo[i] = Index.UNKNOWN;</div><div class="line">        &#125;</div><div class="line">        memo[memo.length - 1] = Index.GOOD;</div><div class="line"></div><div class="line">        for (int i = nums.length - 2; i &gt;= 0; i--) &#123;</div><div class="line">            int furthestJump = Math.min(i + nums[i], nums.length - 1);</div><div class="line">            //去当前点的右边看是否有可达点。</div><div class="line">            for (int j = i + 1; j &lt;= furthestJump; j++) &#123;</div><div class="line">                if (memo[j] == Index.GOOD) &#123;</div><div class="line">                    memo[i] = Index.GOOD;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return memo[0] == Index.GOOD;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###贪心优化（贪心策略）<br>上面的时间复杂度为O（mn），m是数组中最大值，n是数组个数。在分析上面循环的过程中，我们发现找到的第一个点可以到达一个可达点，那么当前位置就不需要再判断后面的步数。也就是说，一个点只要找到离他最近的可达点，那么它就变成了下一轮的可达点。下一轮一旦有一个点可以达到它，那么该点又成为下一轮新的可达点。<br>这也就告诉我们，对于每个点，只要找到它右边第一个可达点即可。<br>这也就是典型的贪心策略。<br>我们可以从右向左，在某个可达点左边找一个最近的点可以达到它，更新该最近点为新的可达点，以此类推，知道最后的一个可达点是起始点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public boolean canJump(int[] nums) &#123;</div><div class="line">        int lastPos = nums.length - 1;</div><div class="line">        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (i + nums[i] &gt;= lastPos) &#123;</div><div class="line">                lastPos = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return lastPos == 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##题目2<br>给一个非负数组，从数组中选取任意个数字求和，要求所选元素均不相邻，求最大和。</p>
<p>###直接寻找递归关系<br>对于比较简单的dp，也可以寻找递推关系求解：<br>这到题的递推关系在于，对于每一个新的元素，都可以选择取或者不取，用一个数组dp记录前面不同长度数组的最大和，那么对当前元素dp[i]，如果不取则最大和为dp[i-1],如果取则最大值为dp[i-2]+num[i];可以很轻易的根据递推关系写出动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] dp = new int[nums.length+1];</div><div class="line">        dp[0] = 0;</div><div class="line">        dp[1] = nums[0];</div><div class="line">		for(int i = 2;i&lt;nums.length;i++)&#123;</div><div class="line">			dp[i] = Math.max(dp[i-1],nums[i]+dp[i-2]);</div><div class="line">		&#125;</div><div class="line">		return dp[nums.length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同经典的钢条切割背包问题一样， <strong>对于一个新出现的元素，选与不选是构成递归的重要策略</strong>。比如leetcode两道题目 ：<a href="https://leetcode.com/problems/house-robber/，" target="_blank" rel="external">https://leetcode.com/problems/house-robber/，</a><br><a href="https://leetcode.com/problems/house-robber-ii/，" target="_blank" rel="external">https://leetcode.com/problems/house-robber-ii/，</a><br>都是对于一个新出现的元素，进行选与不选两种决策去寻找递推关系，动态规划可能的O(N)解法基本也只会出现在这种决策中。</p>
<p>###空间优化<br>到这里还不算完，我们看见，对于每个dp[i]的计算，仅和dp[i-1]，dp[i-2]有关，这也告诉我们根本不需要一个数组，因为以前用过的值在后面不会再使用。这样，仅仅使用两个变量就可以达到效果，空间复杂度也从O(N)降到了O(1)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int rob(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int a =0,b = nums[0];</div><div class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</div><div class="line">            int temp = b;</div><div class="line">            b = Math.max(b,a+nums[i]);</div><div class="line">            a = temp;</div><div class="line">        &#125;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>##题目3<br>一个二维非负数组，找出从最左上到最右下的最小距离，只可以向右或者向下移动。</p>
<p>###直接寻找递推关系<br>这道题基本是二维中最简单的了，直接看到某一点(i,j)的最短距离怎么求就可以。用二维数组记录到每个点的最短距离dp[i][j]，可以直接根据递推关系 dp[i][j] = min{dp[i-1][j],dp[i][j-1]}就可以求解。</p>
<p>###二维空间优化<br>一维动态规划可以通过空间优化达到常数级别的空间复杂度，同样二维动态规划也可以进一步优化。<br>首先，根据递归关系，我们发现每个位置只和上面i-1和左边j-1的值有关，于是可以采用数组滚动的方法。<br>在计算第i行的时候，只存储第i－1行的最短距离，比如计算(i,j)点，数组中dp[j]到右边的元素是二维表中（i-1,j)右边的元素。而数组中 dp[j-1]以及其左边的元素，是 二维表中 (i,j-1)及其左边的元素。<br>其实，就是计算将第i行计算过的结果存在数组前半部分，而后半部分是之前计算上一行存储的最短距离，用于以后计算使用。相当于通过滚动，覆盖了不再被需要的值。<br>如下面的简图，其实就是把一个数组分成两半，左边存储dp[i][j-1]所要用的数据，右边是dp[i-1][j]使用的数据。<br><img src="http://img.blog.csdn.net/20161028143815979" alt="这里写图片描述"></p>
<p>优化过的代码如下，空间复杂度降到了O(n).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int minPathSum(int[][] grid) &#123;</div><div class="line">        //空间压缩，数组滚动方法。</div><div class="line">        int m = grid.length,n = grid[0].length;</div><div class="line">        int[] dp = new int[n];</div><div class="line">        dp[0] = grid[0][0];</div><div class="line">        for(int i=1;i&lt;n;i++)</div><div class="line">            dp[i] =dp[i-1] + grid[0][i];</div><div class="line">        for(int i=1;i&lt;m;i++)</div><div class="line">            for(int j=0;j&lt;n;j++)</div><div class="line">                dp[j] = (j&gt;0?Math.min(dp[j - 1],dp[j]):dp[j]) + grid[i][j];</div><div class="line">        return dp[n-1];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>题目4、5：<br>这两道题目是一维的动态规划，对于一维的动态规划很难从基本的暴力解法逐步推导过去，更多的是寻找递推关系，类似于钢条切割问题。个人还是比较头疼的。<br>第一个题目：<br>地址：<a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="external">https://leetcode.com/problems/maximum-subarray/</a><br>题目是在一个数组中，寻找连续的数，获得最大和。<br>比如：[-2,1,-3,4,-1,2,1,-5,4]数组，最大和是子数组[4,-1,2,1]为6。</p>
<p>一维动态规划，寻找递推关系。为了表明是dp问题，设置一个数组，dp[i]表示包含nums[i]的子数组的最大和。从左到右遍历数组，每新添一个数时，计算dp[i］，可以知道新添的数要么和前面最大和子数组累加，得到dp[i]＋nums[i]，要么自己作为一个新的子数组的唯一元素，和是nums[i]，则有递推关系 dp[i] ＝ max(nums[i],dp[i-1] * nums[i])。<br>注意，dp[i]是包含第i个元素的局部最优解，全局最优解每次获得局部最优解比较一下就行。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    //空间可以被优化</div><div class="line">    public int maxSubArray(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] dp = new int[nums.length];</div><div class="line">        int r = nums[0];</div><div class="line">        dp[0] = nums[0];</div><div class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</div><div class="line">            int n = nums[i];</div><div class="line">            dp[i] = Math.max(n,dp[i-1]+n);</div><div class="line">            r = Math.max(dp[i],r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>第二个题目类似，只不过是乘法最大值。乘法就是要跟踪一下局部的最大值和最小值即可，因为乘法最小值乘以负数也可能出现最大值。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int maxProduct(int[] nums) &#123;</div><div class="line">        if(nums == null || nums.length == 0) return 0;</div><div class="line">        int[] max = new int[nums.length];</div><div class="line">        int[] min = new int[nums.length];</div><div class="line">        int r = nums[0];</div><div class="line">        max[0] = r;</div><div class="line">        min[0] = r;</div><div class="line">        for (int i = 1;i&lt;nums.length;i++) &#123;</div><div class="line">            int n = nums[i];</div><div class="line">            int a = max[i - 1] * n;</div><div class="line">            int b = min[i - 1] * n;</div><div class="line">            max[i] = Math.max(n, Math.max(a,b));</div><div class="line">            min[i] = Math.min(n, Math.min(a, b));</div><div class="line">            r = Math.max(max[i], r);</div><div class="line">        &#125;</div><div class="line">        return r;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显，两个题目都可以优化成O（1）空间，这里为了表示明显不进行优化，读者可以自己尝试一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划是一种算法思想，刚入门的时候可能感觉十分难以掌握，总是会有看了题不知道怎么做，但是一看答案就恍然大悟的感觉。结合这一段时间的学习，在这里做一下总结。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#解题思路&lt;br&gt;在解题的过程中，首先可以主动寻找递推关系，比如对当前数组进行逐步拉伸，看新
    
    </summary>
    
    
  </entry>
  
</feed>
